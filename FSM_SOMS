#%% First method
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd
from scipy.signal import find_peaks

def getiext(sper, runtime, y0, taui, tauy, kiy):

    pretimes=[]
    i=1
    while sper*i<runtime:
        pretimes.append(sper*i)
        i+=1
    
    Iext = np.zeros(runtime)
    y = np.zeros_like(Iext)
    # Time evolution
    for i in range(1, runtime):
        if i in pretimes:
            y[i-1] = y0  # reset just before update
    
        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy*dt
    
        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext*dt
    return Iext

dtype=0
if dtype==0:
    dir1=r'C:\Users\ogamb\OneDrive\Desktop\Research\FSM_pyramidal'
if dtype == 1:
    dir1=r'C:\Users\olgud\OneDrive\Desktop\PhD\3-Research\Neuron\SOM'
os.chdir(dir1)

df = pd.read_csv("Table0.csv")
data=np.array(df)

names=df.columns

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 11 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]

# Processing the data
I = 25*I
vd=50*vd
dt=0.1e-3

names = {
    0: 'DE-F-10 Hz', 1: 'DE-F-40 Hz',
    2: 'DE-M-10 Hz', 3: 'DE-M-40 Hz',
    4: 'DE-S-10 Hz', 5: 'DE-S-40 Hz',
    6: 'NR-F-10 Hz', 7: 'NR-F-40 Hz',
    8: 'NR-M-10 Hz', 9: 'NR-M-40 Hz',
    10: 'NR-S-10 Hz', 11: 'NR-S-40 Hz'
}

#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-60,-65.5,-64,-63.8])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.00011]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -40]

v=np.zeros(len(I))
v[0]=vd[0]
aps=[]
for i in range(1,len(I)):
    dvdt=((-g[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    v[i]=v[i-1]+dvdt*dt
    if v[i-1]>vth[dnum]:
        v[i]=vb[dnum]
        aps.append(i)

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Second method
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 7 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

v=np.zeros(len(I))
v[0]=vd[0]
aps=[]
refper=40
aptimer=np.inf
posttimer=False
for i in range(1,len(I)):
    
    if posttimer==False:
        dvdt=((-g[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    if posttimer==True:
        dvdt=((-gr[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/Cr[dnum]
        
    if aptimer != np.inf:
        v[i] = v[i-1]
    else:
        v[i] = v[i-1]+dvdt*dt
    
    if I[i]>I[i-1]:
        posttimer=False
        
    if aptimer != np.inf:
        aptimer-=1
    if v[i-1]>vth[dnum]:
        v[i]=vbr[dnum]
        aps.append(i)
        aptimer=refper
        posttimer=True
    if aptimer==0:
        aptimer=np.inf

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Third method

dnum= 11 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-60,-65.5,-64,-63.8])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
gb=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.0014]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -40]



dt=0.1e-3

# Better low fit, slightly overshooting the high fit
taug=0.02
c1=2
aps=[]
g=np.zeros_like(I)
v=np.zeros(len(I))
v[0]=vd[0]
for i in range(1,len(I)):
    dvdt=((-g[i-1]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    v[i]=v[i-1]+dvdt*dt
    
    dgdt=-(g[i-1]-gb[dnum])/taug+c1*I[i-1]
    g[i]=g[i-1]+dgdt*dt
    
    if v[i]>vth[dnum]:
        v[i]=vb[dnum]
        aps.append(i)
    
    
    
fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()
#%% Fourth method
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd

dtype=0
if dtype==0:
    dir1=r'C:\Users\ogamb\OneDrive\Desktop\Research\FSM_pyramidal'
if dtype == 1:
    dir1=r'C:\Users\olgud\OneDrive\Desktop\PhD\3-Research\Neuron\SOM'
os.chdir(dir1)

df = pd.read_csv("Table0.csv")
data=np.array(df)

names=df.columns

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 9 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-60,-65.5,-64,-63.8])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.00011]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -40]

v=np.zeros(len(I))
v[0]=vd[0]


aps=[]
r=0.1
vbf=-40
vbs=-40
iS=np.zeros_like(v)
iF=np.zeros_like(v)
gf=0.001
gs=0.001
for i in range(1,len(I)):
    dvdt=((-r*iS[i-1]-(1-r)*iF[i-1]+I[i-1]))/C[dnum]
    v[i]=v[i-1]+dvdt*dt
    
    diFdt = gf*(v[i-1]-vbf)
    diSdt = gs*(v[i-1]-vbs)
    
    iS[i]=iS[i-1]+diSdt*dt
    iF[i]=iF[i-1]+diFdt*dt
    

    
    if v[i-1]>vth[dnum]:
        v[i]=vb[dnum]
        aps.append(i)

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Fifth method - ratio S/F (Mixed)
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 8 # <----------------------------------- neuron number (8 or 9 here)
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='z':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

v=np.zeros(len(I))
v[0]=vd[0]
aps=[]

r=0.1

iS=np.zeros_like(v)
iF=np.zeros_like(v)

refper=40
aptimer=np.inf
posttimer=False
for i in range(1,len(I)):
    
    if dnum==8: # fast
        if posttimer==False:
            icurr = r*g[6]*(v[i-1]-vb[dnum])+(1-r)*g[10]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[6]*(v[i-1]-vb[dnum])+(1-r)*gr[10]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/Cr[dnum]
    if dnum==9: # slow
        
        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/Cr[dnum]
    else: # slow
        if posttimer==False:
            icurr = g[dnum]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/C[dnum]
        if posttimer==True:
            icurr = gr[dnum]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/Cr[dnum]
    
    if aptimer != np.inf:
        v[i] = v[i-1]
    else:
        v[i] = v[i-1]+dvdt*dt
    
    if I[i]>I[i-1]:
        posttimer=False
        
    if aptimer != np.inf:
        aptimer-=1
    if v[i-1]>vth[dnum]:
        v[i]=vbr[dnum] # vb[dnum]
        aps.append(i)
        aptimer=refper
        posttimer=True
    if aptimer==0:
        aptimer=np.inf

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()
#%% 6th method - FPT tests, period version
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# Parameters

sper = 7 # ms, stimulation period
runtime = int(4e3)

y0 = 1500
taui = 0.001
tauy = 0.0025
kiy = 1


    
Iext=getiext(sper, runtime, y0, taui, tauy, kiy)

# =============================================================================
# ## Comment out
# # Plot
# plt.plot(np.linspace(0,1,len(Iext)), Iext, label = 'Simulated current')
# plt.plot(np.linspace(0,1,len(Iext)), I, label='Experimental current')
# plt.xlabel('Time (sec)')
# plt.ylabel('Current')
# plt.tight_layout()
# plt.legend(loc='upper left', framealpha=1)
# plt.show()
# #%%
# =============================================================================

def gettmean(r, I, g, vb, dnum, C, Cr):
    v=np.zeros(len(I))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(I)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]
            
        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt
        
        if I[i]>I[i-1]:
            posttimer=False
            
        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    
    aptimes=np.array(apinds)*dt
    tmean = np.mean(np.diff(aptimes))
    return tmean

# =============================================================================
# gettmean(0.1, I, g, vb, dnum, C, Cr)
# #%%
# =============================================================================

rlist=np.linspace(0,1,100)
tlist=[]
for i,r in enumerate(rlist):
    # print(i, len(rlist))
    tmean=gettmean(r, I, g, vb, dnum, C, Cr)
    tlist.append(tmean)
tlist=np.array(tlist)
    
plt.plot(rlist, 1/tlist)
plt.xlabel('Percentage of fast SOM synapses')
plt.ylabel('Output frequency (Hz)')
plt.plot([],[],'', label='Input frequency = {} Hz'.format(
    np.around(1000/sper,3)))
plt.legend()
plt.show()


# =============================================================================
# r=0.1
# perlist=np.arange(1, 1000, 100)
# tlist=[]
# for per in perlist:
#     Iext=getiext(per, runtime, y0, taui, tauy, kiy)
#     tmean=gettmean(r, Iext, g, vb, dnum, C, Cr)
#     tlist.append(tmean)
# tlist=np.array(tlist)
#     
# plt.plot(perlist, 1/tlist)
# plt.xlabel('Time between presynaptic APs (ms)')
# plt.ylabel('Output frequency (Hz)')
# plt.show()
# =============================================================================

#%% 7th - Frequency version

def getiext(f, runtime, y0, taui, tauy, kiy, dt):

    pretimes = []
    i = 1
    while (i / f) < (runtime * dt):  # convert to seconds
        pretimes.append(int((i / f) / dt))  # convert time to index
        i += 1

    Iext = np.zeros(runtime)
    y = np.zeros_like(Iext)
    # Time evolution
    for i in range(1, runtime):
        if i in pretimes:
            y[i-1] = y0  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt

    return Iext

def gettmean(r, I, g, vb, dnum, C, Cr):
    v=np.zeros(len(I))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(I)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]
            
        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt
        
        if I[i]>I[i-1]:
            posttimer=False
            
        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# Parameters

f = 20 # Hz
runtime_sec = 1 # total runtime in seconds
runtime = int(runtime_sec / dt)  # number of simulation steps

y0 = 1300
taui = 0.001
tauy = 0.0025
kiy = 1

r=1
Iext = getiext(f, runtime, y0, taui, tauy, kiy, dt)

# =============================================================================
# # Plot
# fs=15
# v, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
# fig, ax = plt.subplots(2,1, figsize=(6,4))
# ax[0].plot(np.arange(len(Iext)), Iext, label = 'Iext')
# ax[0].set_xticks([])
# ax[0].set_ylabel('Input\ncurrent', fontsize=fs)
# ax[0].tick_params(axis='both', labelsize=fs)
# # =============================================================================
# # ax[0].plot(np.arange(len(I)), I, label='I')
# # =============================================================================
# ax[1].plot(np.arange(len(Iext)), v, color='k')
# ax[1].set_xlabel('Time (ms)', fontsize=fs)
# ax[1].set_ylabel('Membrane\npotential', fontsize=fs)
# ax[1].tick_params(axis='both', labelsize=fs)
# plt.show()
# #%%
# =============================================================================

# =============================================================================
# gettmean(0.1, I, g, vb, dnum, C, Cr)
# #%%
# =============================================================================

rlist=np.linspace(0,1,100)
tlist=[]
for i,r in enumerate(rlist):
    # print(i, len(rlist))
    _, tmean=gettmean(r, Iext, g, vb, dnum, C, Cr)
    tlist.append(tmean)
foutlist=1/np.array(tlist)

fs=15
plt.plot(rlist, foutlist)
plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
plt.ylabel('Output frequency (Hz)', fontsize=fs)
# =============================================================================
# plt.ylim([0, np.max(foutlist)])
# =============================================================================
plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(f))
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.show()

# =============================================================================
# rlist2=[0, 0.25, 0.5, 0.75, 1]
# flist=np.linspace(1,100,100)
# foutlist=[]
# for i,r in enumerate(rlist2):
#     print(i, len(rlist2))
#     tlist=[]
#     for j, f in enumerate(flist):
#         print(i, len(rlist2), j, len(flist))
#         Iext=getiext(f, 10, y0, taui, tauy, kiy, dt)
#         _, tmean = gettmean(r, Iext, g, vb, dnum, C, Cr)
#         tlist.append(tmean)
#     fout=1/np.array(tlist)  
#     foutlist.append(fout)
#     
# for i,fout in enumerate(foutlist):
#     plt.plot(flist, fout, label='r={}'.format(np.around(rlist2[i],2)))
#     
# plt.legend()
# plt.xlabel('Input frequency (Hz)')
# plt.ylabel('Output frequency (Hz)')
# plt.show()
# =============================================================================
#%% 8 - Reproduce Fig.4.b
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 11 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -39]

#     0    1    2     3    4    5    6    7    8   9    10   11
tauvt=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -39]

#     0    1    2     3    4    5    6    7    8   9    10   11
cth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -39]

tauvt=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.5]
cth=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

v=np.zeros(len(I))
vt=np.zeros_like(v)
vt[0]=vth[dnum]
v[0]=vd[0]
aps=[]
refper=40
aptimer=np.inf
posttimer=False
for i in range(1,len(I)):
    
    if posttimer==False:
        dvdt=((-g[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    if posttimer==True:
        dvdt=((-gr[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/Cr[dnum]
        
    dvtdt=-(vt[i-1]-vth[dnum])/tauvt[dnum]
    
    vt[i]=vt[i-1]+dvtdt*dt
        
    if aptimer != np.inf:
        v[i] = v[i-1]
    else:
        v[i] = v[i-1]+dvdt*dt
        
    
    if I[i]>I[i-1]:
        posttimer=False
        
    if aptimer != np.inf:
        aptimer-=1
        
    # Postsynaptic AP
    if v[i-1]>vt[i-1]:
        v[i]=vbr[dnum]
        aps.append(i)
        aptimer=refper
        posttimer=True
        vt[i]=vt[i]+cth[dnum]*np.random.binomial(50,0.1)
    if aptimer==0:
        aptimer=np.inf

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
# =============================================================================
# plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='base threshold',
#          color='k', linestyle='--', alpha=0.6)
# =============================================================================
plt.plot(vt, label='threshold',
         color='r', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()
#%% 9th - Ratio - old bad

# =============================================================================
# def getiext(f, runtime, y0, taui, tauy, kiy, dt):
# 
#     pretimes = []
#     i = 1
#     while (i / f) < (runtime * dt):  # convert to seconds
#         pretimes.append(int((i / f) / dt))  # convert time to index
#         i += 1
# 
#     Iext = np.zeros(runtime)
#     y = np.zeros_like(Iext)
#     # Time evolution
#     for i in range(1, runtime):
#         if i in pretimes:
#             y[i-1] = y0  # reset just before update
# 
#         dy = -y[i-1] / tauy
#         y[i] = y[i-1] + dy * dt
# 
#         dIext = -Iext[i-1] / taui + kiy * y[i-1]
#         Iext[i] = Iext[i-1] + dIext * dt
# 
#     return Iext
# 
# def gettmean(r, I, g, vb, dnum, C, Cr):
#     v=np.zeros(len(I))
#     v[0]=vd[0]
#     apinds=[]
#     refper=40
#     aptimer=np.inf
#     posttimer=False
#     for i in range(1,len(I)):
# 
#         if posttimer==False:
#             icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
#             dvdt=((-icurr+Iext[i-1]))/C[dnum]
#         if posttimer==True:
#             icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
#             dvdt=((-icurr+Iext[i-1]))/Cr[dnum]
#             
#         if aptimer != np.inf:
#             v[i] = v[i-1]
#         else:
#             v[i] = v[i-1]+dvdt*dt
#         
#         if I[i]>I[i-1]:
#             posttimer=False
#             
#         if aptimer != np.inf:
#             aptimer-=1
#         if v[i-1]>vth[dnum]:
#             v[i]=vbr[dnum] # vb[dnum]
#             apinds.append(i)
#             aptimer=refper
#             posttimer=True
#         if aptimer==0:
#             aptimer=np.inf
# # =============================================================================
# #     # Comment out
# #     fig,ax=plt.subplots(2,1)
# #     ax[0].plot(Iext)
# #     ax[1].plot(range(len(vd)), v)
# # =============================================================================
#     aptimes=np.array(apinds)*dt
#     ssaptimes=aptimes[int(0.3*len(aptimes)):]
#     tmean = np.mean(np.diff(ssaptimes))
#     return v, tmean
# 
# # 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# # 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4
# 
# dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
# #                0   1   2   3   4    5     6      7    8   9  10  11
# vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
# #                0   1   2   3   4    5     6       7    8   9     10    11
# vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
# #    0        1           2          3        4         5
# C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
#    0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
# #    6        7          8        9          10       11
# #    0        1           2          3        4         5
# Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
#    0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
# #    6        7          8        9          10       11
# #    0        1          2      3        4        5
# g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
#    0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
# #    6        7       8        9       10       11
# #    0        1          2      3        4        5
# gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
#    0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
# #    6        7       8        9       10       11
# #     0    1    2     3    4    5    6    7    8   9    10   11
# vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]
# 
# # Parameters
# 
# f = 20 # Hz
# runtime_sec = 1 # total runtime in seconds
# runtime = int(runtime_sec / dt)  # number of simulation steps
# 
# y0 = 1300
# taui = 0.001
# tauy = 0.0025
# kiy = 1
# 
# r=1
# Iext = getiext(f, runtime, y0, taui, tauy, kiy, dt)
# 
# # =============================================================================
# # # Plot
# # fs=15
# # v, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
# # fig, ax = plt.subplots(2,1, figsize=(6,4))
# # ax[0].plot(np.arange(len(Iext)), Iext, label = 'Iext')
# # ax[0].set_xticks([])
# # ax[0].set_ylabel('Input\ncurrent', fontsize=fs)
# # ax[0].tick_params(axis='both', labelsize=fs)
# # # =============================================================================
# # # ax[0].plot(np.arange(len(I)), I, label='I')
# # # =============================================================================
# # ax[1].plot(np.arange(len(Iext)), v, color='k')
# # ax[1].set_xlabel('Time (ms)', fontsize=fs)
# # ax[1].set_ylabel('Membrane\npotential', fontsize=fs)
# # ax[1].tick_params(axis='both', labelsize=fs)
# # plt.show()
# # #%%
# # =============================================================================
# 
# # =============================================================================
# # gettmean(0.1, I, g, vb, dnum, C, Cr)
# # #%%
# # =============================================================================
# 
# rlist=np.linspace(0,1,100)
# tlist=[]
# for i,r in enumerate(rlist):
#     print(i, len(rlist))
#     _, tmean=gettmean(r, Iext, g, vb, dnum, C, Cr)
#     tlist.append(tmean)
# foutlist=1/np.array(tlist)
# 
# fs=15
# plt.plot(rlist, foutlist)
# plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
# plt.ylabel('Output frequency (Hz)', fontsize=fs)
# # =============================================================================
# # plt.ylim([0, np.max(foutlist)])
# # =============================================================================
# plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(f))
# plt.legend(fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.show()
# 
# # =============================================================================
# # rlist2=[0, 0.25, 0.5, 0.75, 1]
# # flist=np.linspace(1,100,100)
# # foutlist=[]
# # for i,r in enumerate(rlist2):
# #     print(i, len(rlist2))
# #     tlist=[]
# #     for j, f in enumerate(flist):
# #         print(i, len(rlist2), j, len(flist))
# #         Iext=getiext(f, 10, y0, taui, tauy, kiy, dt)
# #         _, tmean = gettmean(r, Iext, g, vb, dnum, C, Cr)
# #         tlist.append(tmean)
# #     fout=1/np.array(tlist)  
# #     foutlist.append(fout)
# #     
# # for i,fout in enumerate(foutlist):
# #     plt.plot(flist, fout, label='r={}'.format(np.around(rlist2[i],2)))
# #     
# # plt.legend()
# # plt.xlabel('Input frequency (Hz)')
# # plt.ylabel('Output frequency (Hz)')
# # plt.show()
# # =============================================================================
# =============================================================================

#%% 9th - Ratio 2 with increasing inputs -- GOOD

def fit_line(times, points):
    """
    Fits a line y = mx + b to the given points and times.

    Parameters:
    times (array-like): x-values (e.g., time)
    points (array-like): y-values (e.g., observed data)

    Returns:
    tuple: (m, b) where y = mx + b
    """
    times = np.asarray(times)
    points = np.asarray(points)
    
    if len(times) != len(points):
        raise ValueError("times and points must have the same length.")
    
    m, b = np.polyfit(times, points, 1)
    return m, b

def interpolated_line(x, r, f, f1, f2, a1, a2, a3, b1, b2, b3):
    """
    Computes y = m(r,f) * x + b(r,f), where:
    - m(r,f) and b(r,f) interpolate between (r=0,f1)->(r=0,f2)
    - and become constant at r=1 (equal to a3, b3), no frequency dependence.
    """
    lam = (f - f1) / (f2 - f1)
    m = (1 - r) * ((1 - lam) * a1 + lam * a2) + r * a3
    b = (1 - r) * ((1 - lam) * b1 + lam * b2) + r * b3
    return m * x + b

def getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1):
    
    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    slope = f*(1-r)*a1+f*r*b1
    presizes = slope*np.linspace(0, runtime*dt, runtime)+c1

    # new thing
# =============================================================================
#     slope = (1-r)*a1+b1*r*f
#     tarr=np.linspace(0, runtime*dt, runtime)
#     # presizes = slope*tarr+c1
#     presizes = interpolated_line(tarr, r, f, 10, 40, 0.2, 2, 1, 4, 2, 6)
# =============================================================================

    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

def getiext3(f, taui, tauy, dt, r, a, b):
    
    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    slope=a*f*(1-r)+b*f*r
    const=1
    presizes=slope*np.linspace(0, runtime*dt, runtime)+const

    Iext = np.zeros(runtime)
    # Time evolution
    j=0
    for i in range(0, runtime):
        dIext = -Iext[i-1] / taui 
        Iext[i] = Iext[i-1] + dIext * dt
        if i in pretimes:
            # print(presizes[i])
            Iext[i] = presizes[i]  # reset just before update
            j+=1
    return Iext, runtime, presizes, slope, const

f = 40 # Hz
taui = 0.001
tauy = 0.0025
kiy = 100
r=0
a=1
b=0.1

a1=0.1
b1=0.01
c1=2

Iext, y, runtime, slope, presizes = getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
# Iext, runtime, presizes, slope, const = getiext3(f, taui, tauy, dt, r, a, b)

plt.plot(Iext)
plt.plot(presizes)
plt.show()
#%%
# =============================================================================
# f = 100 # Hz
# taui = 0.001
# tauy = 0.0025
# kiy = 100
# r=0
# Iext,y,yline = getiext2(f, taui, tauy, kiy, dt, r)
# 
# fig,ax=plt.subplots(2,1)
# ax[0].plot(np.linspace(0,len(yline)*dt,len(yline)),Iext)
# ax[1].plot(np.linspace(0,len(yline)*dt,len(yline)),y)
# ax[1].plot(np.linspace(0,len(yline)*dt,len(yline)),yline)
# plt.show()
# 
# #%%
# =============================================================================

def gettmean(r, Iext, g, vb, dnum, C, Cr):
    v=np.zeros(len(Iext))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(Iext)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]

        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt

        if Iext[i]>Iext[i-1]:
            posttimer=False

        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes

def gettmean2(r, Iext, g, vb, dnum, C, Cr):
    v=np.zeros(len(Iext))
    v[0]=vd[0]
    apinds=[]
    for i in range(1,len(Iext)):
        icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
        dvdt=((-icurr+Iext[i-1]))/C[dnum]
        v[i] = v[i-1]+dvdt*dt
        if v[i-1]>vth[dnum]:
            v[i]=vb[dnum] # vb[dnum]
            apinds.append(i)
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# Parameters
f = 40 # Hz
taui = 0.001
tauy = 0.0025
kiy = 500

# =============================================================================
# r=1
# Iext, ytest, mtest, btest = getiext(f, taui, tauy, kiy, dt,r)
# plt.plot(ytest)
# plt.plot(np.linspace(0, len(Iext), len(Iext))*mtest+btest)
# #%%
# =============================================================================

# =============================================================================
# def shift_forward(arr, n):
#     """
#     Shift the array forward (right) by n indices and remove the last n elements.
#     The result has the same length as the input array.
#     
#     Parameters:
#     arr (np.ndarray): 1D input array.
#     n (int): Number of indices to shift.
# 
#     Returns:
#     np.ndarray: Shifted array.
#     """
#     if n <= 0:
#         return arr.copy()
#     elif n >= len(arr):
#         return np.zeros_like(arr)
#     else:
#         return np.concatenate((np.zeros(n, dtype=arr.dtype), arr[:-n]))
# =============================================================================
    

# =============================================================================
# plt.plot(Iext)
# #%%
# =============================================================================
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

# =============================================================================
#
## Get the real current data slope
#
# dnum= 10 # <----------------------------------- neuron number
# dsize= 'z' # f full, z zoomed
# dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
# dlens=[4000,12000]
# if dsize=='f':
#     I=data[:, dnum]
# if dsize=='z':
#     I=data[:, dnum][:dlens[dsnum]]
# # Processing the data
# I = 25*I
# from scipy.signal import find_peaks
# peaks, _ = find_peaks(I)
# peakvals=I[peaks]
# peakratio=(peakvals[-1]-peakvals[0])/(peaks[-1]-peaks[0])/dt
# maxmin=peakvals[-1]/peakvals[0]
# print(peakratio)
# print(maxmin)
# plt.plot(np.linspace(0,len(I)*dt,len(I)),I, label='data')
# plt.title('{}'.format(names[dnum]), fontsize=fs)
# # =============================================================================
# # plt.plot(Iext, label='Iext')
# # =============================================================================
# b=(peakvals[-1]*peaks[0]-peakvals[0]*peaks[-1])/(peaks[0]-peaks[-1])
# y=peakratio*np.linspace(0,10000*dt, 10000)+b
# plt.plot(np.linspace(0,len(y)*dt,len(y)),y, label='y={}x+{}'.format(np.around(peakratio,2), np.around(b,2)))
# # =============================================================================
# # plt.text(200, peakvals[3], 'y={}x+{}'.format(np.around(peakratio,2), np.around(b,2)))
# # plt.text(200, peakvals[-4], 'max peak / min peak = {}'.format(np.around(maxmin,3)))
# # =============================================================================
# plt.plot([],[], ' ', label=' peak max/min = {}'.format(np.around(maxmin,3) ))
# plt.xlabel('Time (sec)', fontsize=fs)
# plt.ylabel('Current', fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.legend(fontsize=fs-4, loc='upper left')
# plt.show()
# #%%
# 
# =============================================================================
def getline(Iext):
    peaks, _ = find_peaks(Iext)
    peakvals=Iext[peaks]
    peakratio=(peakvals[-1]-peakvals[0])/(peaks[-1]-peaks[0])/dt
    maxmin=peakvals[-1]/peakvals[0]
# =============================================================================
#     print(peakratio)
#     print(maxmin)
# =============================================================================
    b=(peakvals[-1]*peaks[0]-peakvals[0]*peaks[-1])/(peaks[0]-peaks[-1])
    y=peakratio*np.linspace(0,len(Iext)*dt, len(Iext))+b
    return y, peakratio, b

# Plot
r=1
f=100
a=1
b=0.1

a1=0.1
b1=0.001
c1=2

Iext, y, runtime, slope, presizes = getiext(f, taui, tauy, kiy, dt,r, a1, b1, c1)
# Iext, y, m, b, runtime = getiext3(f, taui, tauy, dt, r, a, b)

plt.plot(np.linspace(0,len(y), len(y)), y)
#%% Integration current check

# Parameters
f = 40 # Hz
taui = 0.001
tauy = 0.0025   
kiy = 500
r=0

a=0.6
b=0.05

a1=0.13
b1=0.01
c1=2

fs=15

Iext, yi, mi, bi, runtime = getiext(f, taui, tauy, kiy, dt,r, a1, b1, c1)
Iext3, y, m, b, runtime = getiext3(f, taui, tauy, dt, r, a, b)
tdata=np.linspace(0, len(Iext)*dt, len(Iext))
plt.plot(tdata, Iext3, label='Spikes')
plt.plot(tdata, Iext, label='Realistic')

plt.tick_params(axis='both', labelsize=fs)
plt.xlabel('Time (sec)', fontsize=fs)
plt.ylabel('Current', fontsize=fs)
plt.plot([], [], ' ', label='Input frequency = {}'.format(f))
plt.legend(loc='upper left', fontsize=fs)

plt.figure()
i1=np.cumsum(Iext)
i3=np.cumsum(Iext3)
plt.plot(tdata, i1, label='Realistic')
plt.plot(tdata, i3, label='Spikes')
plt.legend(loc='upper left', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.xlabel('Time (sec)', fontsize=fs)
plt.ylabel('Charge (Integral of current)', fontsize=fs)
plt.plot([], [], ' ', label='Input frequency = {}'.format(f))
plt.legend(fontsize=fs)

#%%


v, tmeantest, naps, aps = gettmean(r, Iext, g, vb, dnum, C, Cr)

yi, peakratioi, byi = getline(Iext)

fs=15
fig, ax = plt.subplots(3, 1, figsize=(6, 5))
# Originally ax[2] -> now ax[0]
ax[0].set_title('10 injections @ {} Hz, r={}'.format(f, r))
ax[0].plot(np.linspace(0, len(y)*dt, len(y)), y) # y plot

yline=slope*np.linspace(0, len(Iext)*dt, len(Iext))+c1
ax[0].plot(np.linspace(0, len(Iext)*dt, len(Iext)), #input
            yline, # output
           color='r', # Red line <----------------
           label='y=(af(1-r)+bfr)t+c, y={} x + {}'.format(
               np.around(slope,2), np.around(c1,2)))
# =============================================================================
# ax[0].plot(np.linspace(0, len(Iext)*dt, len(Iext)), 
#            # f*(0.05*f*(1-r)+r)/9*np.linspace(0,9/f,len(Iext))+1, 
#            slope*np.linspace(0, len(Iext)*dt, len(Iext))+const,
#            color='k',
#            label='{}t + {}'.format(np.around(slope,2), 
#                                             np.around(const,2)))
# =============================================================================
ax[0].tick_params(axis='both', labelsize=fs)
ax[0].set_ylabel('Input for\nspikes', fontsize=fs)
ax[0].set_xticks([])
ax[0].set_ylim([-0.1, np.max(yline)+2])
ax[0].legend(fontsize=fs-3, loc='upper left')

# Originally ax[0] -> now ax[1]

ax[1].plot(np.linspace(0, len(Iext)*dt, len(Iext)), Iext, color='orange')
ax[1].set_xticks([])
ax[1].set_ylabel('Input\ncurrent', fontsize=fs)
ax[1].tick_params(axis='both', labelsize=fs)
ax[1].plot(np.linspace(0, len(yi)*dt, len(yi)), yi, 
           label='y={}t+{}'.format(np.around(peakratioi, 2), np.around(byi, 2)), 
           color='g')
ax[1].set_ylim([-0.1, np.max(yi)+0.5])
ax[1].legend(loc='upper left', fontsize=fs-3)

# Originally ax[1] -> now ax[2]
ax[2].plot(np.linspace(0, len(Iext)*dt, len(Iext)), v)
ax[2].set_xlabel('Time (sec)', fontsize=fs)
ax[2].set_ylabel('Membrane\npotential', fontsize=fs)
ax[2].tick_params(axis='both', labelsize=fs)
ax[2].plot(np.linspace(0, len(Iext)*dt, len(Iext)), vth[dnum]*np.ones(len(Iext)), 
           color='k')
ax[2].scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x', zorder=2)
ax[2].plot([], [], ' ', label='#APs={}'.format(naps))
ax[2].legend(loc='upper left', handlelength=1, fontsize=fs-3)
ax[2].set_ylim([-67, -21])
# ax[2].text(0.225, -35, 'AP', fontsize=fs)
ax[2].set_xlabel('Time (sec)', fontsize=fs)

plt.show()

#%% current directly
# Parameters
f = 40 # Hz
taui = 0.001
tauy = 0.0025
# Plot
r=0
f=40
a=0.3
b=0.1

a1=0.05
b1=0.001
c1=2

# Iext, yi, mi, bi, runtime = getiext(f, taui, tauy, kiy, dt,r)
Iext, runtime, presizes, slope, const = getiext3(f, taui, tauy, dt, r, a, b)
v, tmeantest, naps, aps = gettmean(r, Iext, g, vb, dnum, C, Cr)

fs=15
fig, ax = plt.subplots(2, 1, figsize=(6, 5))

tarr=np.linspace(0, runtime*dt, runtime)
ax[0].plot(tarr, Iext) 
ax[0].plot(tarr, presizes, label='(a*f(1-r)+b*fr)t+c')
ax[0].plot([], [], ' ', label='={}*t + {}'.format(slope, const))  # same as above
ax[0].tick_params(axis='both', labelsize=fs)
ax[0].set_ylabel('Current', fontsize=fs)
# ax[0].set_xticks([])
ax[0].set_title('10 injections @ {} Hz, r={}'.format(f, r))
ax[0].legend(fontsize=fs-3, loc='upper left')

ax[1].plot(tarr, v)
ax[1].set_xlabel('Time (sec)', fontsize=fs)
ax[1].set_ylabel('Membrane\npotential (mV)', fontsize=fs)
ax[1].tick_params(axis='both', labelsize=fs)
ax[1].plot(np.linspace(0, len(Iext)*dt, len(Iext)), vth[dnum]*np.ones(len(Iext)), 
           color='k')
ax[1].scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x', zorder=2)
ax[1].plot([], [], ' ', 
           label='#APs={}'.format(naps))
ax[1].legend(loc='upper left', handlelength=1, fontsize=fs-3)
ax[1].set_ylim([-67, -26])
# ax[2].text(0.225, -35, 'AP', fontsize=fs)
ax[1].set_xlabel('Time (sec)', fontsize=fs)

#%%

# =============================================================================
# gettmean(0.1, I, g, vb, dnum, C, Cr)
# #%%
# =============================================================================

a=2
b=0.1
f=5

a1=0.05
b1=0.001
c1=2

rlist, foutlist, napslist = getstats(f)
plt.plot(rlist, napslist)
#%% Get the AP numbers


def getstats(f):
    # Fix fin plot
    rlist=np.linspace(0,1,100)
    tlist=[]
    rateslist=[]
    napslist=[]
    for ind,r in enumerate(rlist):
        print(ind, len(rlist))
        Iext, _, _, _, runtime = getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
        # Iext, runtime, presizes, slope, const = getiext3(f, taui, tauy, dt, r, a, b)
        _, tmean, naps, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
        rateslist.append(naps/runtime/dt)
        tlist.append(tmean)
        napslist.append(naps)
    foutlist=1/np.array(tlist)
    return rlist, foutlist, napslist

a=0.6
b=0.05

a1=0.13
b1=0.01
c1=2

# a1=0.2
# b1=0.03
# c1=2

# a=0.5
# b=0.2
flist=[5, 10, 20, 40]
aps=[]
for ind, f in enumerate(flist):
    print(ind, len(flist))
    _, _, napslist = getstats(f)
    aps.append(napslist)

#naps
fs=15
for i, apl in enumerate(aps):
    plt.plot(rlist, apl, label='f={}'.format(flist[i]))
plt.xlabel('Proportion of fast synapses', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
# =============================================================================
# plt.ylim([0, np.max(foutlist)])
# =============================================================================
# plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(f))
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.title('Realistic injection', fontsize=fs)
# plt.title('Spike injection', fontsize=fs)
plt.show()

    
# =============================================================================
# fs=15
# plt.plot(rlist, foutlist)
# plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
# plt.ylabel('Output frequency (Hz)', fontsize=fs)
# # =============================================================================
# # plt.ylim([0, np.max(foutlist)])
# # =============================================================================
# plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(f))
# plt.legend(fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.show()
# =============================================================================

# =============================================================================
# fs=15
# plt.plot(rlist, rateslist)
# plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
# plt.ylabel('Output rates (Hz)', fontsize=fs)
# # =============================================================================
# # plt.ylim([0, np.max(foutlist)])
# # =============================================================================
# plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(f))
# plt.legend(fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.show()
# =============================================================================

# =============================================================================
# #naps
# fs=15
# plt.plot(rlist, napslist)
# plt.xlabel('Proportion of fast synapses', fontsize=fs)
# plt.ylabel('# of APs', fontsize=fs)
# # =============================================================================
# # plt.ylim([0, np.max(foutlist)])
# # =============================================================================
# plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(f))
# plt.legend(fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.show()
# =============================================================================
#%% fix r plot

def getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1):
    
    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    slope = f*(1-r)*a1+r*b1
    presizes = slope*np.linspace(0, runtime*dt, runtime)+c1

    
    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

a1=0.13
b1=0.01
c1=2

taui = 0.001
tauy = 0.0025
kiy=500

rlist2=[0, 0.25, 0.5, 0.75, 1]
flist=np.linspace(1,100,100)
foutlist=[]
napslist=[]
for i,r in enumerate(rlist2):
    print(i, len(rlist2))
    tlist=[]
    napslisti=[]
    for j, f in enumerate(flist):
        print(i, len(rlist2), j, len(flist))
        Iext, runtime, presizes, slope, const=getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
        v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
        tlist.append(tmean)
        napslisti.append(naps)
    fout=1/np.array(tlist)  
    foutlist.append(fout)
    napslist.append(napslisti)

for i,fout in enumerate(foutlist):
    plt.plot(flist, napslist[i], label='r={}'.format(np.around(rlist2[i],2)), marker='o')
    
plt.legend()
plt.xlabel('Input frequency (Hz)')
plt.ylabel('# of APs')
plt.show()

#%% Plot all 12 I traces in 2x6 grid
from scipy.signal import find_peaks
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(2, 6, figsize=(24, 8))  # 2 rows x 6 columns

sfreq = 40
dlens = [4000, 12000]
dt = 1 / 10000  # 10 kHz sampling rate

for idx, dnum in enumerate(range(12)):  # loop over 0-11
    dsize = 'z'  # zoomed
    dsnum = 1 if dnum in [0, 2, 4, 6, 8, 10] else 0
    
    if dsize == 'z':
        I = data[:, dnum][:dlens[dsnum]]

    I = 25 * I

    # Peak analysis & line fitting
    peaks, _ = find_peaks(I)
    if len(peaks) >= 2:
        peakvals = I[peaks]
        ratio = peakvals[-1] / peakvals[0]

        t_first, t_last = peaks[0] * dt, peaks[-1] * dt
        y_first, y_last = peakvals[0], peakvals[-1]
        slope = (y_last - y_first) / (t_last - t_first)
        intercept = y_first - slope * t_first
        t_line = [0, len(I) * dt]
        y_line = [slope * t_line[0] + intercept, slope * t_line[1] + intercept]
    else:
        ratio = float('nan')
        slope, intercept = float('nan'), float('nan')
        t_line, y_line = [0, len(I) * dt], [0, 0]

    # Subplot placement
    row, col = divmod(idx, 6)
    t = np.arange(len(I)) * dt
    ax[row, col].plot(t, I, label='ratio={:.2f}\ny={:.3f}t+{:.2f}'.format(ratio, slope, intercept))
    ax[row, col].plot(t_line, y_line, color='r', linestyle='-')
    ax[row, col].set_title('{}'.format(names[dnum]))
    ax[row, col].set_xlabel('Time (s)')
    ax[row, col].set_ylabel('Current (pA)')
    ax[row, col].legend(fontsize=8)

plt.tight_layout()
plt.show()

#%% 3x4

from scipy.signal import find_peaks
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(3, 4, figsize=(18, 12))  # 3 rows x 4 columns

sfreq = 40
dlens = [4000, 12000]
dt = 1 / 10000  # 10 kHz sampling rate

for idx, dnum in enumerate(range(12)):  # loop over 0-11
    dsize = 'z'  # zoomed
    dsnum = 1 if dnum in [0, 2, 4, 6, 8, 10] else 0
    
    if dsize == 'z':
        I = data[:, dnum][:dlens[dsnum]]

    I = 25 * I

    # Peak analysis & line fitting
    peaks, _ = find_peaks(I)
    if len(peaks) >= 2:
        peakvals = I[peaks]
        ratio = peakvals[-1] / peakvals[0]

        t_first, t_last = peaks[0] * dt, peaks[-1] * dt
        y_first, y_last = peakvals[0], peakvals[-1]
        slope = (y_last - y_first) / (t_last - t_first)
        intercept = y_first - slope * t_first
        t_line = [0, len(I) * dt]
        y_line = [slope * t_line[0] + intercept, slope * t_line[1] + intercept]
    else:
        ratio = float('nan')
        slope, intercept = float('nan'), float('nan')
        t_line, y_line = [0, len(I) * dt], [0, 0]

    # Subplot placement
    row, col = divmod(idx, 4)
    t = np.arange(len(I)) * dt
    ax[row, col].plot(t, I, label='ratio={:.2f}\ny={:.3f}t+{:.2f}'.format(ratio, slope, intercept))
    ax[row, col].plot(t_line, y_line, color='r', linestyle='-')
    ax[row, col].set_title('{}'.format(names[dnum]))
    ax[row, col].set_xlabel('Time (s)')
    ax[row, col].set_ylabel('Current (pA)')
    ax[row, col].legend(fontsize=14)

plt.tight_layout()
plt.show()

#%% New changes - Slope increases (LINEAR) proportional to frequency for slow type
# Fix the averages of the fast type

def getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1):

    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    slope = f*(1-r)*a1+b1*r
    presizes = slope*np.linspace(0, runtime*dt, runtime)+c1
    
    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

def getstats(f):
    # Fix fin plot
    rlist=np.linspace(0,1,100)
    tlist=[]
    rateslist=[]
    napslist=[]
    for ind,r in enumerate(rlist):
        print(ind, len(rlist))
        Iext, _, _, _, runtime = getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
        # Iext, runtime, presizes, slope, const = getiext3(f, taui, tauy, dt, r, a, b)
        _, tmean, naps, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
        rateslist.append(naps/runtime/dt)
        tlist.append(tmean)
        napslist.append(naps)
    foutlist=1/np.array(tlist)
    return rlist, foutlist, napslist

def gettmean(r, Iext, g, vb, dnum, C, Cr):
    v=np.zeros(len(Iext))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(Iext)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]

        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt

        if Iext[i]>Iext[i-1]:
            posttimer=False

        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# a=0.6
# b=0.05

a1=0.13 # slow slope coeff
b1=0.1 # fast slope coeff
c1=2

taui = 0.001
tauy = 0.0025
kiy=500

rlist=np.linspace(0,1,100)

# =============================================================================
# r=0
# f=40
# fs=15
# flist2 = [5, 10, 20, 40]
# Iextlist=[]
# for fi in flist2:
#     Iext, _, _, _, runtime = getiext(fi, taui, tauy, kiy, dt, r, a1, b1, c1)
#     Iextlist.append(Iext)
# for i in range(len(Iextlist)):
#     plt.plot(np.arange(len(Iextlist[i]))*dt, Iextlist[i], label='{} Hz'.format(flist2[i]))
# plt.legend(loc='upper right')
# plt.xlabel('Time', fontsize=fs)
# plt.ylabel('Input current', fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.title('10 current injections, r={}'.format(r), fontsize=fs)
# plt.show()
# #%%
# =============================================================================

# Run tests
flist=[5, 10, 20, 40]
aps=[]
for ind, f in enumerate(flist):
    print(ind, len(flist))
    _, _, napslist = getstats(f)
    aps.append(napslist)

#naps
fs=15
for i, apl in enumerate(aps):
    plt.plot(rlist, apl, label='f={}'.format(flist[i]))
plt.xlabel('Proportion of fast synapses', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.title('Realistic injection', fontsize=fs)
# plt.title('Spike injection', fontsize=fs)
plt.show()
#%% Fix r plot with new (proportional, fixed fast)
import numpy as np

def getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1):

    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    slope = f*(1-r)*a1+b1*r
    presizes = slope*np.linspace(0, runtime*dt, runtime)+c1

    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes
a1=0.13
b1=0.01
c1=2

taui = 0.001
tauy = 0.0025
kiy=500

rlist2=[0, 0.25, 0.5, 0.75, 1]
# rlist2=np.linspace(0.8, 1, 5)
rlist2=[0]
flist=np.linspace(1,60,100)
foutlist=[]
napslist=[]
for i,r in enumerate(rlist2):
    print(i, len(rlist2))
    tlist=[]
    napslisti=[]
    for j, f in enumerate(flist):
        print(i, len(rlist2), j, len(flist))
        Iext, runtime, presizes, slope, const=getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
        v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
        tlist.append(tmean)
        napslisti.append(naps)
    fout=1/np.array(tlist)  
    foutlist.append(fout)
    napslist.append(napslisti)

for i,fout in enumerate(foutlist):
    plt.plot(flist, napslist[i], label='r={}'.format(np.around(rlist2[i],2)), marker='o')
    
plt.legend(fontsize=fs-3)
plt.xlabel('Input frequency (Hz)', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Statistics on the number of APs for each proportion
import matplotlib.pyplot as plt
import numpy as np

fs = 15  # font size

napslist2 = []
for naps in napslist:
    naps2 = [x for x in naps if x != 9]
    napslist2.append(naps2)

n = len(napslist2)

# Flatten all lists to find the global min and max
all_values = np.concatenate(napslist2)
min_val, max_val = np.min(all_values), np.max(all_values)

# Create bin edges to include every integer in the full range
bins = np.arange(min_val, max_val + 2)  # +2 so rightmost bin includes max

# Calculate the global max count for consistent ylim
max_count = 0
for data in napslist2:
    counts, _ = np.histogram(data, bins=bins)
    max_count = max(max_count, counts.max())

# Set up vertical subplots
fig, axes = plt.subplots(n, 1, figsize=(6, 2.5 * n), sharex=True)

# Get the default color cycle from matplotlib
prop_cycle = plt.rcParams['axes.prop_cycle']
colors = prop_cycle.by_key()['color']

# Plot each histogram with cycling colors
for i, data in enumerate(napslist2):
    ax = axes[i] if n > 1 else axes
    color = colors[i % len(colors)]
    ax.hist(data, bins=bins, align='left', edgecolor='black', rwidth=0.8, color=color)
    ax.set_ylabel('Counts, r={}'.format(np.around(rlist2[i], 3)), fontsize=fs)
    ax.set_ylim(0, max_count + 1)  # Same ylim for all
    ax.tick_params(axis='both', labelsize=fs)
    ax.grid(axis='y', linestyle='--', alpha=0.5)

# Common x-axis settings
plt.xticks(np.arange(min_val, max_val + 1), fontsize=fs)
axes[-1].set_xlabel('# of APs', fontsize=fs)
axes[0].set_title('Histograms of # of APs for each r', fontsize=fs)
plt.show()

variances=[]
means=[]
cvs=[]
for i, data in enumerate(napslist2):
    counts, _ = np.histogram(data, bins=bins)
    vari=np.var(counts)
    meani=np.mean(counts)
    variances.append(vari)
    means.append(meani)
    cvs.append(vari/meani**2)
#%%  Random inputs

def getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1):

    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    slope = f*(1-r)*a1+b1*r
    presizes = slope*np.linspace(0, runtime*dt, runtime)+c1

    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

def getstats(f):
    # Fix fin plot
    rlist=np.linspace(0,1,100)
    tlist=[]
    rateslist=[]
    napslist=[]
    for ind,r in enumerate(rlist):
        print(ind, len(rlist))
        Iext, _, _, _, runtime = getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
        # Iext, runtime, presizes, slope, const = getiext3(f, taui, tauy, dt, r, a, b)
        _, tmean, naps, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
        rateslist.append(naps/runtime/dt)
        tlist.append(tmean)
        napslist.append(naps)
    foutlist=1/np.array(tlist)
    return rlist, foutlist, napslist

def gettmean(r, Iext, g, vb, dnum, C, Cr):
    v=np.zeros(len(Iext))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(Iext)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]

        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt

        if Iext[i]>Iext[i-1]:
            posttimer=False

        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

def simulate(f, y0, taui, ki, tmax, delta_t):
    
        tlist=[]
        ylist=[]
        Iextlist=[]
        
        Iext=0
        y=0
        
        tcurr=0
        timer = delta_t
        
        while tcurr < tmax:
            t0=np.random.exponential(1/f) # action potential
            t1 = timer
            
            if t0 < t1:
                y = y0
                tmin=t0
                timer-=tmin
            else:
                Iextlist.append(Iext)
                ylist.append(y)
                tlist.append(tcurr)
                timer=delta_t
                tmin=timer
            
            tcurr += tmin

            # Update the continuous dynamics
            
            Iext += (-Iext/taui + ki*y)*tmin
            y += (-y/tauy)*tmin
            
        return tlist, ylist, Iextlist
    
    
def gettmean(r, Iext, g, vb, dnum, C, Cr):
    v=np.zeros(len(Iext))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(Iext)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]

        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt

        if Iext[i]>Iext[i-1]:
            posttimer=False

        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes
    
f=20 # input frequency
y0=0.01 # value of y to jump to
tauy=0.1 # time constant of y
taui=0.005 # time constant of Iext
ki=3200 # conversion of y to iext
tmax=3
delta_t=0.001

r=1

res=simulate(f, y0, taui, ki, tmax, delta_t)

# =============================================================================
# plt.subplot(4,1,1)
# plt.plot(res[0], res[1])
# plt.xticks([])
# plt.ylabel('Spike variable')
# =============================================================================

plt.subplot(3,1,1)

plt.plot(res[0], res[2])
plt.xticks([])
plt.ylabel('Current')

Iext=res[2]


v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
plt.subplot(3,1,2)
plt.plot(res[0], v)
plt.xlabel('Time (sec)')
plt.ylabel('Membrane \npotential (mV)')

navgs=50
tmeanavg=[]
rlist=np.linspace(0,1,10)
napsmean=[]
for j, r in enumerate(rlist):
    tmeani=[]
    napsi=[]
    for i in range(navgs): 
        print(j, len(rlist), i, navgs)
        v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
        tmeani.append(tmean)
        napsi.append(naps)
    tmeanavg.append(np.mean(tmeani))
    napsmean.append(np.mean(napsi))
       
plt.subplot(3,1,3)
plt.plot(rlist, np.array(napsmean)/tmax)
plt.ylabel('Mean firing rate')
plt.xlabel('Proportion of fast synapses')
plt.tight_layout()
plt.show()

    #%%
#e

# a=0.6
# b=0.05

a1=0.13 # slow slope coeff
b1=0.1 # fast slope coeff
# c1=2

taui = 0.001
tauy = 0.0025
kiy=500

rlist=np.linspace(0,1,100)

# =============================================================================
# r=1
# f=40
# fs=15
# flist2 = [5, 10, 20, 40]
# Iextlist=[]
# for fi in flist2:
#     Iext, _, _, _, runtime = getiext(fi, taui, tauy, kiy, dt, r, a1, b1, c1)
#     Iextlist.append(Iext)
# for i in range(len(Iextlist)):
#     plt.plot(np.arange(len(Iextlist[i]))*dt, Iextlist[i], label='{} Hz'.format(flist2[i]))
# plt.legend(loc='upper right')
# plt.xlabel('Time', fontsize=fs)
# plt.ylabel('Input current', fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.title('10 current injections, r={}'.format(r), fontsize=fs)
# plt.show()
# #%%
# =============================================================================

# Run tests
flist=[5, 10, 20, 40]
aps=[]
for ind, f in enumerate(flist):
    print(ind, len(flist))
    _, _, napslist = getstats(f)
    aps.append(napslist)

#naps
fs=15
for i, apl in enumerate(aps):
    plt.plot(rlist, apl, label='f={}'.format(flist[i]))
plt.xlabel('Proportion of fast synapses', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.title('Realistic injection', fontsize=fs)
# plt.title('Spike injection', fontsize=fs)
plt.show()
#%% Reverse the proportion for DE
import numpy as np

def getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1):

    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    slope = (1-r)*a1+b1*r*f
    presizes = slope*np.linspace(0, runtime*dt, runtime)+c1

    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

a1=0.13 # slow slope
b1=0.05 # fast slope
c1=2 # constant

taui = 0.001
tauy = 0.0025
kiy=500

f=0.1
r=0

Iext, runtime, presizes, slope, const=getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)

fig, ax = plt.subplots(2,1)
ax[0].plot(Iext)
ax[1].plot(v)
print(naps)


#%%
rlist2=[0, 0.25, 0.5, 0.75, 1]
# rlist2=[1]
flist=np.linspace(0.1,60,100)
foutlist=[]
napslist=[]
for i,r in enumerate(rlist2):
    print(i, len(rlist2))
    tlist=[]
    napslisti=[]
    for j, f in enumerate(flist):
        print(i, len(rlist2), j, len(flist))
        Iext, runtime, presizes, slope, const=getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
        v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
        tlist.append(tmean)
        napslisti.append(naps)
    fout=1/np.array(tlist)  
    foutlist.append(fout)
    napslist.append(napslisti)

for i,fout in enumerate(foutlist):
    plt.plot(flist, napslist[i], label='r={}'.format(np.around(rlist2[i],2)), marker='o')
    
plt.legend(fontsize=fs-3)
plt.xlabel('Input frequency (Hz)', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.show()
#%% Statistics for DE reversed fast dependent on frequency
import matplotlib.pyplot as plt
import numpy as np

fs = 15  # font size

napslist2 = []
for naps in napslist:
    naps2 = [x for x in naps if x != 9]
    napslist2.append(naps2)

n = len(napslist2)

# Flatten all lists to find the global min and max
all_values = np.concatenate(napslist2)
min_val, max_val = np.min(all_values), np.max(all_values)

# Create bin edges to include every integer in the full range
bins = np.arange(min_val, max_val + 2)  # +2 so rightmost bin includes max

# Calculate the global max count for consistent ylim
max_count = 0
for data in napslist2:
    counts, _ = np.histogram(data, bins=bins)
    max_count = max(max_count, counts.max())

# Set up vertical subplots
fig, axes = plt.subplots(n, 1, figsize=(6, 2.5 * n), sharex=True)

# Get the default color cycle from matplotlib
prop_cycle = plt.rcParams['axes.prop_cycle']
colors = prop_cycle.by_key()['color']

# Plot each histogram with cycling colors
for i, data in enumerate(napslist2):
    ax = axes[i] if n > 1 else axes
    color = colors[i % len(colors)]
    ax.hist(data, bins=bins, align='left', edgecolor='black', rwidth=0.8, color=color)
    ax.set_ylabel('Counts, r={}'.format(np.around(rlist2[i], 3)), fontsize=fs)
    ax.set_ylim(0, max_count + 1)  # Same ylim for all
    ax.tick_params(axis='both', labelsize=fs)
    ax.grid(axis='y', linestyle='--', alpha=0.5)

# Common x-axis settings
plt.xticks(np.arange(min_val, max_val + 1), fontsize=fs)
axes[-1].set_xlabel('# of APs', fontsize=fs)
axes[0].set_title('Histograms of # of APs for each r', fontsize=fs)
plt.show()

variances=[]
means=[]
cvs=[]
for i, data in enumerate(napslist2):
    counts, _ = np.histogram(data, bins=bins)
    vari=np.var(counts)
    meani=np.mean(counts)
    variances.append(vari)
    means.append(meani)
    cvs.append(vari/meani**2)
    
    
#%% Get the parameters for matching the current
def getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1):

    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    slope = f*(1-r)*a1+b1*r
    presizes = slope*np.linspace(0, runtime*dt, runtime)+c1
    
    

    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

def getstats(f):
    # Fix fin plot
    rlist=np.linspace(0,1,100)
    tlist=[]
    rateslist=[]
    napslist=[]
    for ind,r in enumerate(rlist):
        print(ind, len(rlist))
        Iext, _, _, _, runtime = getiext(f, taui, tauy, kiy, dt, r, a1, b1, c1)
        # Iext, runtime, presizes, slope, const = getiext3(f, taui, tauy, dt, r, a, b)
        _, tmean, naps, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
        rateslist.append(naps/runtime/dt)
        tlist.append(tmean)
        napslist.append(naps)
    foutlist=1/np.array(tlist)
    return rlist, foutlist, napslist

def gettmean(r, Iext, g, vb, dnum, C, Cr):
    v=np.zeros(len(Iext))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(Iext)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]

        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt

        if Iext[i]>Iext[i-1]:
            posttimer=False

        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes


dtype=0
if dtype==0:
    dir1=r'C:\Users\ogamb\OneDrive\Desktop\Research\FSM_pyramidal'
if dtype == 1:
    dir1=r'C:\Users\olgud\OneDrive\Desktop\PhD\3-Research\Neuron\SOM'
os.chdir(dir1)

df = pd.read_csv("Table0.csv")
data=np.array(df)

names=df.columns

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

def zform(z1,z2, f1,f2,f):
    return z1+(z2-z1)/(f2-f1)*(f-f1)

def getiext(f, taui, tauy, kiy, dt, r, m01,b01,m04,b04,m11,b11,m14,b14):

    pretimes = [int(i/f/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    # slope = f*(1-r)*a1+b1*r*f
    
    m0f= zform(m01, m04, 10, 40, f)
    b0f= zform(b01, b04, 10, 40, f)
    m1f= zform(m11, m14, 10, 40, f)
    b1f= zform(b11, b14, 10, 40, f)
    slope = m0f*(1-r)+m1f*r
    const=b0f*(1-r)+b1f*r
    presizes = slope*np.linspace(0, runtime*dt, runtime)+const
    
    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

def geti(dnum):

    dsize= 'z' # f full, z zoomed
    dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0 # Fixed
    dlens=[4000,12000]
    if dsize=='f':
        I=data[:, dnum]
    if dsize=='z':
        I=data[:, dnum][:dlens[dsnum]]

    # Processing the data
    I = 25*I
    return I

Is=[geti(x) for x in [6,7,10,11]]

m01=4.5 # S10
b01=1.5
m04=20 #S40
b04=0.5
m11=1.5 #F10
b11=0.7
m14=12 #F40
b14=2.1

m01,b01,m04,b04,m11,b11,m14,b14

taui = 0.0005
tauy = 0.0025
kiy=500

Iext100, _, _, _, _ =getiext(10, taui, tauy, kiy, dt, 0, m01,b01,m04,b04,m11,b11,m14,b14)
Iext400, _, _, _, _ =getiext(40, taui, tauy, kiy, dt, 0, m01,b01,m04,b04,m11,b11,m14,b14)
Iext101, _, _, _, _ =getiext(10, taui, tauy, kiy, dt, 1, m01,b01,m04,b04,m11,b11,m14,b14)
Iext401, _, _, _, _ =getiext(40, taui, tauy, kiy, dt, 1, m01,b01,m04,b04,m11,b11,m14,b14)

fig, ax = plt.subplots(2,2)
ax[0,0].plot(Is[0][1000:])
ax[0,1].plot(Is[1][1000:])
ax[1,0].plot(Is[2][1000:])
ax[1,1].plot(Is[3][1000:])

ax[0,0].set_title('S10')
ax[0,1].set_title('S40')
ax[1,0].set_title('F10')
ax[1,1].set_title('F40')

ax[0,0].plot(Iext100, alpha=0.5)
ax[0,1].plot(Iext400, alpha=0.5)
ax[1,0].plot(Iext101, alpha=0.5)
ax[1,1].plot(Iext401, alpha=0.5)
plt.tight_layout()
plt.show()

#%%

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# a=0.6
# b=0.05

a1=0.13 # slow slope coeff
b1=0.1 # fast slope coeff
# c1=2

taui = 0.001
tauy = 0.0025
kiy=500

rlist=np.linspace(0,1,100)

r=1
f=40
fs=15
flist2 = [5, 10, 20, 40]
Iextlist=[]
for fi in flist2:
    Iext, _, _, _, runtime = getiext(fi, taui, tauy, kiy, dt, r, a1, b1, c1)
    Iextlist.append(Iext)
for i in range(len(Iextlist)):
    plt.plot(np.arange(len(Iextlist[i]))*dt, Iextlist[i], label='{} Hz'.format(flist2[i]))
plt.legend(loc='upper right')
plt.xlabel('Time', fontsize=fs)
plt.ylabel('Input current', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.title('10 current injections, r={}'.format(r), fontsize=fs)
plt.show()
#%%

# Run tests
flist=[5, 10, 20, 40]
aps=[]
for ind, f in enumerate(flist):
    print(ind, len(flist))
    _, _, napslist = getstats(f)
    aps.append(napslist)

#naps
fs=15
for i, apl in enumerate(aps):
    plt.plot(rlist, apl, label='f={}'.format(flist[i]))
plt.xlabel('Proportion of fast synapses', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.title('Realistic injection', fontsize=fs)
# plt.title('Spike injection', fontsize=fs)
plt.show()


#%% Get the parameters which fit the current between 10 and 40 Hz linearly for NR

def zform(z1,z2, f1,f2,f):
    return z1+(z2-z1)/(f2-f1)*(f-f1)

def getiext(f, taui0,tauy0,kiy0,taui1,tauy1,kiy1,dt,r,m01,b01,m04,b04,m11,b11,m14,b14):

    pretimes = [int(i/f/dt)+1002 for i in range(0,10)]
    extra=2000
    runtime = pretimes[-1]+extra
    # presizes = np.linspace(1, f*(1-r)*0.05+f*r*0.01+2, len(pretimes))
    # presizes = np.linspace(1, f*(1-r)*a+f*r*b+c, len(pretimes))
    # slope = f*(1-r)*a1+b1*r*f
    
    m0f= zform(m01, m04, 10, 40, f)
    b0f= zform(b01, b04, 10, 40, f)
    m1f= zform(m11, m14, 10, 40, f)
    b1f= zform(b11, b14, 10, 40, f)
    
    slope = m0f*(1-r)+m1f*r
    const=b0f*(1-r)+b1f*r
    presizes = slope*np.linspace(0, runtime*dt, runtime)+const
    
    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[i]  # reset just before update

        dy = -y[i-1] / (tauy0*(1-r)+tauy1*r)
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / (taui0*(1-r)+taui1*r) + (kiy0*(1-r)+kiy1*r) * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, runtime, slope, presizes

def getstats(f, taui0, tauy0, kiy0, taui1, tauy1, kiy1, dt, r, 
                                 m01, b01, m04, b04, m11, 
                                 b11, m14, b14, g, vb, dnum, C, Cr):
    # Fix fin plot
    rlist=np.linspace(0,1,100)
    tlist=[]
    rateslist=[]
    napslist=[]
    for ind,r in enumerate(rlist):
        print(ind, len(rlist))
        Iext, _, _, _, runtime = getiext(f, taui0, tauy0, kiy0, 
                                         taui1, tauy1, kiy1, dt, r, 
                                         m01, b01, m04, b04, m11, 
                                         b11, m14, b14)
        _, tmean, naps, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
        rateslist.append(naps/runtime/dt)
        tlist.append(tmean)
        napslist.append(naps)
    foutlist=1/np.array(tlist)
    return rlist, foutlist, napslist

def gettmean(r, Iext, g, vb, dnum, C, Cr):
    v=np.zeros(len(Iext))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(Iext)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]

        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt

        if Iext[i]>Iext[i-1]:
            posttimer=False

        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes



def geti(dnum):

    dsize= 'z' # f full, z zoomed
    dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0 # Fixed
    dlens=[4000,12000]
    if dsize=='f':
        I=data[:, dnum]
        vd=data[:, dnum+13]
    if dsize=='z':
        I=data[:, dnum][:dlens[dsnum]]
        vd=data[:, dnum+13][:dlens[dsnum]]    

    # Processing the data
    I = 25*I
    vd=50*vd
    return I, vd


dtype=0
if dtype==0:
    dir1=r'C:\Users\ogamb\OneDrive\Desktop\Research\FSM_pyramidal'
if dtype == 1:
    dir1=r'C:\Users\olgud\OneDrive\Desktop\PhD\3-Research\Neuron\SOM'
os.chdir(dir1)

df = pd.read_csv("Table0.csv")
data=np.array(df)

names = {
    0: 'DE-F-10 Hz', 1: 'DE-F-40 Hz',
    2: 'DE-M-10 Hz', 3: 'DE-M-40 Hz',
    4: 'DE-S-10 Hz', 5: 'DE-S-40 Hz',
    
    6: 'NR-F-10 Hz', 7: 'NR-F-40 Hz',
    8: 'NR-M-10 Hz', 9: 'NR-M-40 Hz',
    10: 'NR-S-10 Hz', 11: 'NR-S-40 Hz'
}

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)

#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

Is=[]
vs=[]
for num in [6,7,10,11]:
    Ival, vval = geti(num)
    Is.append(Ival)
    vs.append(vval)

m01=1.55 # S10
b01=0.58

m04=12.3 # S40
b04=0.9

m11=3.92 # F10
b11=1.01

m14=16.95 # F40
b14=-1.2

taui0 = 0.00265 # Slow
tauy0 = 0.00075
kiy0 = 360

taui1 = 0.0014 # Fast
tauy1 = 0.00034
kiy1 = 860

Iext100, _, _, _, _ =getiext(10, taui0,tauy0,kiy0,taui1,tauy1,kiy1, dt, 0, m01,b01,m04,b04,m11,b11,m14,b14)
Iext400, _, _, _, _ =getiext(40, taui0,tauy0,kiy0,taui1,tauy1,kiy1, dt, 0, m01,b01,m04,b04,m11,b11,m14,b14)
Iext101, _, _, _, _ =getiext(10, taui0,tauy0,kiy0,taui1,tauy1,kiy1, dt, 1, m01,b01,m04,b04,m11,b11,m14,b14)
Iext401, _, _, _, _ =getiext(40, taui0,tauy0,kiy0,taui1,tauy1,kiy1, dt, 1, m01,b01,m04,b04,m11,b11,m14,b14)

sl=0
ws=100000

ts = [np.linspace(0, len(x), len(x))*dt for x in Is]

tsext=[np.linspace(0, len(x), len(x))*dt for x in [Iext101, Iext401, Iext100, Iext400]]

fig, ax = plt.subplots(2,2)
ax[0,0].plot(ts[0], Is[0][sl:sl+ws])
ax[0,1].plot(ts[1], Is[1][sl:sl+ws])
ax[1,0].plot(ts[2], Is[2][sl:sl+ws])
ax[1,1].plot(ts[3], Is[3][sl:sl+ws], label='data')

ax[0,0].set_title('F10')
ax[0,1].set_title('F40')
ax[1,0].set_title('S10')
ax[1,1].set_title('S40')

ax[0,0].plot(tsext[0], Iext101[sl:sl+ws], alpha=0.5)
ax[0,1].plot(tsext[1], Iext401[sl:sl+ws], alpha=0.5)
ax[1,0].plot(tsext[2], Iext100[sl:sl+ws], alpha=0.5)
ax[1,1].plot(tsext[3], Iext400[sl:sl+ws], alpha=0.5, label='sim.')

ax[0,0].set_xticks([])
ax[0,1].set_xticks([])
# ax[1,0].set_xticks([])
# ax[1,1].set_xticks([])

# ax[0,0].set_yticks([])
# ax[0,1].set_yticks([])
# ax[1,0].set_yticks([])
# ax[1,1].set_yticks([])

ax[1,1].legend(loc='upper right')
ax[1,0].set_xlabel('Time (sec)')
ax[1,1].set_xlabel('Time (sec)')
ax[0,0].set_ylabel('Current')
ax[1,0].set_ylabel('Current')

# =============================================================================
# plt.title('S40')
# plt.plot(Is[3][sl:sl+ws])
# plt.plot(Iext400[sl:sl+ws], alpha=0.5)
# =============================================================================


# =============================================================================
# plt.tight_layout()
# plt.show()
# #%% part 2 to prev
# =============================================================================

idnum=1
#         0        1
vals=[(1,10, 6),(1,40,7),  # fast
      (0,10,10),(0,40,11)] # slow
#         2        3

r,f,dnum=vals[idnum]

nnames=[6,7,10,11]

Iext, _, _, _, _ = getiext(f, taui0,tauy0,kiy0,taui1,tauy1,kiy1, dt, r, m01,b01,m04,b04,m11,b11,m14,b14)
v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
plt.subplot(2,1,1)
plt.plot(Is[idnum], label='data')
plt.title(names[nnames[idnum]])
plt.plot(Iext, alpha=0.5, label='simulation')
plt.legend()
plt.subplot(2,1,2)
plt.plot(vs[idnum])
plt.plot(v, alpha=0.8)
plt.show()

#%% v vs t for r and f for new parameters
r=1
f=60
Iext, _, _, _, _ = getiext(f, taui0,tauy0,kiy0,taui1,tauy1,kiy1, dt, r, m01,b01,m04,b04,m11,b11,m14,b14)
v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
plt.subplot(2,1,1)
tarr=np.linspace(0, len(v), len(v))*dt
plt.plot(tarr, Iext)
plt.xticks([])
plt.title('Input frequency = {} Hz, r={}'.format(f,r), fontsize=fs)
plt.ylabel('Current', fontsize=fs)
plt.subplot(2,1,2)
plt.plot(tarr,v)
plt.plot([], [], ' ', label='# of APs = {}'.format(naps))

_, _, napslist = getstats(f, taui0, tauy0, kiy0, taui1, tauy1, kiy1, 
                          dt, r, m01, b01, m04, b04, m11, b11, m14, 
                          b14, g, vb, dnum, C, Cr)
plt.ylabel('Membrane \npotential (mV)', fontsize=fs)
plt.xlabel('Time (sec)', fontsize=fs)
plt.legend(fontsize=fs, handlelength=-0.7)
print(naps)

#%% Plot of the currents for r and different f values
r=1
fsimlist=[10, 20, 30, 40, 50]
iexts=[]
for i,f in enumerate(fsimlist):
    Iext, _, _, _, _ = getiext(f, taui0,tauy0,kiy0,taui1,tauy1,kiy1, dt, r, m01,b01,m04,b04,m11,b11,m14,b14)
    iexts.append(Iext)

for i, iext in enumerate(iexts):
    plt.plot(np.linspace(0, len(iext), len(iext))*dt, iext, label='f={} Hz'.format(fsimlist[i]))
plt.legend()
plt.title('Proportion of fast synapses (r) = {}'.format(r))
plt.xlabel('Time (sec)')
plt.show()

#%% Plot of # of APs vs r (proportion) with new data-fit parameters

rlist=np.linspace(0,1,100)
flist=[10, 15, 20, 25, 30, 35, 40]
# flist=[10, 15, 20, 25, 30, 40, 50]
# flist=[15, 20, 25, 30, 40, 50, 70]# Plot this one
aps=[]
for ind, f in enumerate(flist):
    print(ind, len(flist))
    _, _, napslist = getstats(f, taui0, tauy0, kiy0, taui1, tauy1, kiy1, 
                              dt, r, m01, b01, m04, b04, m11, b11, m14, 
                              b14, g, vb, dnum, C, Cr)
    aps.append(napslist)

#naps
fs=15
plt.plot([], [], ' ', label='Input:')
for i, apl in enumerate(aps):
    plt.plot(rlist, apl, label='{} Hz'.format(flist[i]))
plt.xlabel('Proportion of fast synapses', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
plt.legend(fontsize=fs-5)
plt.tick_params(axis='both', labelsize=fs)
plt.title('Injections with fit parameters', fontsize=fs)
# plt.title('Spike injection', fontsize=fs)
plt.show()
#%% # of APs vs input frequency (f) for fixed r values (data fit parameters)

rlist2=[0, 0.25, 0.5, 0.75, 1]
# rlist2=np.linspace(0.8, 1, 5)
flist=np.linspace(10, 40, 100)
foutlist=[]
napslist=[]
for i,r in enumerate(rlist2):
    print(i, len(rlist2))
    tlist=[]
    napslisti=[]
    for j, f in enumerate(flist):
        print(i, len(rlist2), j, len(flist))
        Iext, _, _, _, _ =getiext(f, taui0, tauy0, kiy0, taui1, tauy1, kiy1, 
                              dt, r, m01, b01, m04, b04, m11, b11, m14, b14)
        v, tmean, naps, aptimes = gettmean(r, Iext, g, vb, dnum, C, Cr)
        tlist.append(tmean)
        napslisti.append(naps)
    fout=1/np.array(tlist)  
    foutlist.append(fout)
    napslist.append(napslisti)

for i,fout in enumerate(foutlist):
    plt.plot(flist, napslist[i], label='r={}'.format(np.around(rlist2[i],2)), marker='o')

plt.legend(fontsize=fs-3)
plt.xlabel('Input frequency (Hz)', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Statistics on the number of APs for each proportion
import matplotlib.pyplot as plt
import numpy as np

fs = 15  # font size

napslist2 = []
for naps in napslist:
    # naps2 = [x for x in naps if x != 9]
    naps2 = [x for x in naps]
    napslist2.append(naps2)

n = len(napslist2)

# Flatten all lists to find the global min and max
all_values = np.concatenate(napslist2)
min_val, max_val = np.min(all_values), np.max(all_values)

# Create bin edges to include every integer in the full range
bins = np.arange(min_val, max_val + 2)  # +2 so rightmost bin includes max

# Calculate the global max count for consistent ylim
max_count = 0
for data in napslist2:
    counts, _ = np.histogram(data, bins=bins)
    max_count = max(max_count, counts.max())

# Set up vertical subplots
fig, axes = plt.subplots(n, 1, figsize=(6, 2.5 * n), sharex=True)

# Get the default color cycle from matplotlib
prop_cycle = plt.rcParams['axes.prop_cycle']
colors = prop_cycle.by_key()['color']

# Plot each histogram with cycling colors
for i, data in enumerate(napslist2):
    ax = axes[i] if n > 1 else axes
    color = colors[i % len(colors)]
    ax.hist(data, bins=bins, align='left', edgecolor='black', rwidth=0.8, color=color)
    ax.set_ylabel('Counts, r={}'.format(np.around(rlist2[i], 3)), fontsize=fs)
    ax.set_ylim(0, max_count + 1)  # Same ylim for all
    ax.tick_params(axis='both', labelsize=fs)
    ax.grid(axis='y', linestyle='--', alpha=0.5)

# Common x-axis settings
plt.xticks(np.arange(min_val, max_val + 1), fontsize=fs)
axes[-1].set_xlabel('# of APs', fontsize=fs)
axes[0].set_title('Histograms of # of APs for each r', fontsize=fs)
plt.show()

variances=[]
means=[]
cvs=[]
for i, data in enumerate(napslist2):
    counts, _ = np.histogram(data, bins=bins)
    vari=np.var(counts)
    meani=np.mean(counts)
    variances.append(vari)
    means.append(meani)
    cvs.append(vari/meani**2)
