#%% First method
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd
from scipy.signal import find_peaks

dtype=0
if dtype==0:
    dir1=r'C:\Users\ogamb\OneDrive\Desktop\Research\FSM_pyramidal'
if dtype == 1:
    dir1=r'C:\Users\olgud\OneDrive\Desktop\PhD\3-Research\Neuron\SOM'
os.chdir(dir1)

df = pd.read_csv("Table0.csv")
data=np.array(df)

names=df.columns

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 11 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]

# Processing the data
I = 25*I
vd=50*vd
dt=0.1e-3

names = {
    0: 'DE-F-10 Hz', 1: 'DE-F-40 Hz',
    2: 'DE-M-10 Hz', 3: 'DE-M-40 Hz',
    4: 'DE-S-10 Hz', 5: 'DE-S-40 Hz',
    6: 'NR-F-10 Hz', 7: 'NR-F-40 Hz',
    8: 'NR-M-10 Hz', 9: 'NR-M-40 Hz',
    10: 'NR-S-10 Hz', 11: 'NR-S-40 Hz'
}

#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-60,-65.5,-64,-63.8])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.00011]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -40]

v=np.zeros(len(I))
v[0]=vd[0]
aps=[]
for i in range(1,len(I)):
    dvdt=((-g[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    v[i]=v[i-1]+dvdt*dt
    if v[i-1]>vth[dnum]:
        v[i]=vb[dnum]
        aps.append(i)

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Second method
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 9 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

v=np.zeros(len(I))
v[0]=vd[0]
aps=[]
refper=40
aptimer=np.inf
posttimer=False
for i in range(1,len(I)):
    
    if posttimer==False:
        dvdt=((-g[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    if posttimer==True:
        dvdt=((-gr[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/Cr[dnum]
        
    if aptimer != np.inf:
        v[i] = v[i-1]
    else:
        v[i] = v[i-1]+dvdt*dt
    
    if I[i]>I[i-1]:
        posttimer=False
        
    if aptimer != np.inf:
        aptimer-=1
    if v[i-1]>vth[dnum]:
        v[i]=vbr[dnum]
        aps.append(i)
        aptimer=refper
        posttimer=True
    if aptimer==0:
        aptimer=np.inf

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Third method

dnum= 11 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-60,-65.5,-64,-63.8])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
gb=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.0014]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -40]



dt=0.1e-3

# Better low fit, slightly overshooting the high fit
taug=0.02
c1=2
aps=[]
g=np.zeros_like(I)
v=np.zeros(len(I))
v[0]=vd[0]
for i in range(1,len(I)):
    dvdt=((-g[i-1]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    v[i]=v[i-1]+dvdt*dt
    
    dgdt=-(g[i-1]-gb[dnum])/taug+c1*I[i-1]
    g[i]=g[i-1]+dgdt*dt
    
    if v[i]>vth[dnum]:
        v[i]=vb[dnum]
        aps.append(i)
    
    
    
fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()
#%% Fourth method
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd

dtype=0
if dtype==0:
    dir1=r'C:\Users\ogamb\OneDrive\Desktop\Research\FSM_pyramidal'
if dtype == 1:
    dir1=r'C:\Users\olgud\OneDrive\Desktop\PhD\3-Research\Neuron\SOM'
os.chdir(dir1)

df = pd.read_csv("Table0.csv")
data=np.array(df)

names=df.columns

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 9 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-60,-65.5,-64,-63.8])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.00011]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -40]

v=np.zeros(len(I))
v[0]=vd[0]


aps=[]
r=0.1
vbf=-40
vbs=-40
iS=np.zeros_like(v)
iF=np.zeros_like(v)
gf=0.001
gs=0.001
for i in range(1,len(I)):
    dvdt=((-r*iS[i-1]-(1-r)*iF[i-1]+I[i-1]))/C[dnum]
    v[i]=v[i-1]+dvdt*dt
    
    diFdt = gf*(v[i-1]-vbf)
    diSdt = gs*(v[i-1]-vbs)
    
    iS[i]=iS[i-1]+diSdt*dt
    iF[i]=iF[i-1]+diFdt*dt
    

    
    if v[i-1]>vth[dnum]:
        v[i]=vb[dnum]
        aps.append(i)

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()

#%% Fifth method - ratio S/F (Mixed)
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 8 # <----------------------------------- neuron number (8 or 9 here)
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='z':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

v=np.zeros(len(I))
v[0]=vd[0]
aps=[]

r=0.1

iS=np.zeros_like(v)
iF=np.zeros_like(v)

refper=40
aptimer=np.inf
posttimer=False
for i in range(1,len(I)):
    
    if dnum==8: # fast
        if posttimer==False:
            icurr = r*g[6]*(v[i-1]-vb[dnum])+(1-r)*g[10]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[6]*(v[i-1]-vb[dnum])+(1-r)*gr[10]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/Cr[dnum]
    if dnum==9: # slow
        
        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/Cr[dnum]
    else: # slow
        if posttimer==False:
            icurr = g[dnum]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/C[dnum]
        if posttimer==True:
            icurr = gr[dnum]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+I[i-1]))/Cr[dnum]
    
    if aptimer != np.inf:
        v[i] = v[i-1]
    else:
        v[i] = v[i-1]+dvdt*dt
    
    if I[i]>I[i-1]:
        posttimer=False
        
    if aptimer != np.inf:
        aptimer-=1
    if v[i-1]>vth[dnum]:
        v[i]=vbr[dnum] # vb[dnum]
        aps.append(i)
        aptimer=refper
        posttimer=True
    if aptimer==0:
        aptimer=np.inf

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='threshold',
         color='k', linestyle='--', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()
#%% 6th method - FPT tests, period version
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# Parameters

sper = 7 # ms, stimulation period
runtime = int(4e3)

y0 = 1500
taui = 0.001
tauy = 0.0025
kiy = 1

def getiext(sper, runtime, y0, taui, tauy, kiy):

    pretimes=[]
    i=1
    while sper*i<runtime:
        pretimes.append(sper*i)
        i+=1
    
    Iext = np.zeros(runtime)
    y = np.zeros_like(Iext)
    # Time evolution
    for i in range(1, runtime):
        if i in pretimes:
            y[i-1] = y0  # reset just before update
    
        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy*dt
    
        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext*dt
    return Iext
    
Iext=getiext(sper, runtime, y0, taui, tauy, kiy)

# =============================================================================
# ## Comment out
# # Plot
# plt.plot(np.linspace(0,1,len(Iext)), Iext, label = 'Simulated current')
# plt.plot(np.linspace(0,1,len(Iext)), I, label='Experimental current')
# plt.xlabel('Time (sec)')
# plt.ylabel('Current')
# plt.tight_layout()
# plt.legend(loc='upper left', framealpha=1)
# plt.show()
# #%%
# =============================================================================

def gettmean(r, I, g, vb, dnum, C, Cr):
    v=np.zeros(len(I))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(I)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]
            
        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt
        
        if I[i]>I[i-1]:
            posttimer=False
            
        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    
    aptimes=np.array(apinds)*dt
    tmean = np.mean(np.diff(aptimes))
    return tmean

# =============================================================================
# gettmean(0.1, I, g, vb, dnum, C, Cr)
# #%%
# =============================================================================

rlist=np.linspace(0,1,100)
tlist=[]
for i,r in enumerate(rlist):
    print(i, len(rlist))
    tmean=gettmean(r, I, g, vb, dnum, C, Cr)
    tlist.append(tmean)
tlist=np.array(tlist)
    
plt.plot(rlist, 1/tlist)
plt.xlabel('Percentage of fast SOM synapses')
plt.ylabel('Output frequency (Hz)')
plt.plot([],[],'', label='Input frequency = {} Hz'.format(
    np.around(1000/sper,3)))
plt.legend()
plt.show()


# =============================================================================
# r=0.1
# perlist=np.arange(1, 1000, 100)
# tlist=[]
# for per in perlist:
#     Iext=getiext(per, runtime, y0, taui, tauy, kiy)
#     tmean=gettmean(r, Iext, g, vb, dnum, C, Cr)
#     tlist.append(tmean)
# tlist=np.array(tlist)
#     
# plt.plot(perlist, 1/tlist)
# plt.xlabel('Time between presynaptic APs (ms)')
# plt.ylabel('Output frequency (Hz)')
# plt.show()
# =============================================================================

#%% 7th - Frequency version

def getiext(sfreq, runtime, y0, taui, tauy, kiy, dt):

    pretimes = []
    i = 1
    while (i / sfreq) < (runtime * dt):  # convert to seconds
        pretimes.append(int((i / sfreq) / dt))  # convert time to index
        i += 1

    Iext = np.zeros(runtime)
    y = np.zeros_like(Iext)
    # Time evolution
    for i in range(1, runtime):
        if i in pretimes:
            y[i-1] = y0  # reset just before update

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt

    return Iext

def gettmean(r, I, g, vb, dnum, C, Cr):
    v=np.zeros(len(I))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(I)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]
            
        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt
        
        if I[i]>I[i-1]:
            posttimer=False
            
        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# Parameters

sfreq = 20 # Hz
runtime_sec = 1 # total runtime in seconds
runtime = int(runtime_sec / dt)  # number of simulation steps

y0 = 1300
taui = 0.001
tauy = 0.0025
kiy = 1

r=1
Iext = getiext(sfreq, runtime, y0, taui, tauy, kiy, dt)

# =============================================================================
# # Plot
# fs=15
# v, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
# fig, ax = plt.subplots(2,1, figsize=(6,4))
# ax[0].plot(np.arange(len(Iext)), Iext, label = 'Iext')
# ax[0].set_xticks([])
# ax[0].set_ylabel('Input\ncurrent', fontsize=fs)
# ax[0].tick_params(axis='both', labelsize=fs)
# # =============================================================================
# # ax[0].plot(np.arange(len(I)), I, label='I')
# # =============================================================================
# ax[1].plot(np.arange(len(Iext)), v, color='k')
# ax[1].set_xlabel('Time (ms)', fontsize=fs)
# ax[1].set_ylabel('Membrane\npotential', fontsize=fs)
# ax[1].tick_params(axis='both', labelsize=fs)
# plt.show()
# #%%
# =============================================================================

# =============================================================================
# gettmean(0.1, I, g, vb, dnum, C, Cr)
# #%%
# =============================================================================

rlist=np.linspace(0,1,100)
tlist=[]
for i,r in enumerate(rlist):
    print(i, len(rlist))
    _, tmean=gettmean(r, Iext, g, vb, dnum, C, Cr)
    tlist.append(tmean)
foutlist=1/np.array(tlist)

fs=15
plt.plot(rlist, foutlist)
plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
plt.ylabel('Output frequency (Hz)', fontsize=fs)
# =============================================================================
# plt.ylim([0, np.max(foutlist)])
# =============================================================================
plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(sfreq))
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.show()

# =============================================================================
# rlist2=[0, 0.25, 0.5, 0.75, 1]
# flist=np.linspace(1,100,100)
# foutlist=[]
# for i,r in enumerate(rlist2):
#     print(i, len(rlist2))
#     tlist=[]
#     for j, sfreq in enumerate(flist):
#         print(i, len(rlist2), j, len(flist))
#         Iext=getiext(sfreq, 10, y0, taui, tauy, kiy, dt)
#         _, tmean = gettmean(r, Iext, g, vb, dnum, C, Cr)
#         tlist.append(tmean)
#     fout=1/np.array(tlist)  
#     foutlist.append(fout)
#     
# for i,fout in enumerate(foutlist):
#     plt.plot(flist, fout, label='r={}'.format(np.around(rlist2[i],2)))
#     
# plt.legend()
# plt.xlabel('Input frequency (Hz)')
# plt.ylabel('Output frequency (Hz)')
# plt.show()
# =============================================================================
#%% 8 - Reproduce Fig.4.b
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dnum= 11 # <----------------------------------- neuron number
dsize= 'z' # f full, z zoomed
dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
dlens=[4000,12000]
if dsize=='f':
    I=data[:, dnum]
    vd=data[:, dnum+13]
if dsize=='z':
    I=data[:, dnum][:dlens[dsnum]]
    vd=data[:, dnum+13][:dlens[dsnum]]
    
I = 25*I
vd=50*vd
dt=0.1e-3
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -39]

#     0    1    2     3    4    5    6    7    8   9    10   11
tauvt=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -39]

#     0    1    2     3    4    5    6    7    8   9    10   11
cth=[-40, -40, -40, -40, -40, -40, -40, -40, -38, -40, -40, -39]

tauvt=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.5]
cth=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

v=np.zeros(len(I))
vt=np.zeros_like(v)
vt[0]=vth[dnum]
v[0]=vd[0]
aps=[]
refper=40
aptimer=np.inf
posttimer=False
for i in range(1,len(I)):
    
    if posttimer==False:
        dvdt=((-g[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/C[dnum]
    if posttimer==True:
        dvdt=((-gr[dnum]*(v[i-1]-vb[dnum])+I[i-1]))/Cr[dnum]
        
    dvtdt=-(vt[i-1]-vth[dnum])/tauvt[dnum]
    
    vt[i]=vt[i-1]+dvtdt*dt
        
    if aptimer != np.inf:
        v[i] = v[i-1]
    else:
        v[i] = v[i-1]+dvdt*dt
        
    
    if I[i]>I[i-1]:
        posttimer=False
        
    if aptimer != np.inf:
        aptimer-=1
        
    # Postsynaptic AP
    if v[i-1]>vt[i-1]:
        v[i]=vbr[dnum]
        aps.append(i)
        aptimer=refper
        posttimer=True
        vt[i]=vt[i]+cth[dnum]*np.random.binomial(50,0.1)
    if aptimer==0:
        aptimer=np.inf

fs=15
plt.figure(figsize=(9,4))
plt.plot(vd, label='data')
plt.ylabel('membrane potential (mV)', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.plot(v, label='model')
# =============================================================================
# plt.plot(vth[dnum]*np.ones(dlens[dsnum]), label='base threshold',
#          color='k', linestyle='--', alpha=0.6)
# =============================================================================
plt.plot(vt, label='threshold',
         color='r', alpha=0.6)

plt.scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x',
            zorder=2, label='action potentials')
plt.title(names[dnum], fontsize=fs)
plt.legend(loc='upper left', fontsize=fs, bbox_to_anchor=(0.01,0.95))
plt.tick_params(axis='both', labelsize=fs)
plt.show()
#%% 9th - Ratio - old bad

# =============================================================================
# def getiext(sfreq, runtime, y0, taui, tauy, kiy, dt):
# 
#     pretimes = []
#     i = 1
#     while (i / sfreq) < (runtime * dt):  # convert to seconds
#         pretimes.append(int((i / sfreq) / dt))  # convert time to index
#         i += 1
# 
#     Iext = np.zeros(runtime)
#     y = np.zeros_like(Iext)
#     # Time evolution
#     for i in range(1, runtime):
#         if i in pretimes:
#             y[i-1] = y0  # reset just before update
# 
#         dy = -y[i-1] / tauy
#         y[i] = y[i-1] + dy * dt
# 
#         dIext = -Iext[i-1] / taui + kiy * y[i-1]
#         Iext[i] = Iext[i-1] + dIext * dt
# 
#     return Iext
# 
# def gettmean(r, I, g, vb, dnum, C, Cr):
#     v=np.zeros(len(I))
#     v[0]=vd[0]
#     apinds=[]
#     refper=40
#     aptimer=np.inf
#     posttimer=False
#     for i in range(1,len(I)):
# 
#         if posttimer==False:
#             icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
#             dvdt=((-icurr+Iext[i-1]))/C[dnum]
#         if posttimer==True:
#             icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
#             dvdt=((-icurr+Iext[i-1]))/Cr[dnum]
#             
#         if aptimer != np.inf:
#             v[i] = v[i-1]
#         else:
#             v[i] = v[i-1]+dvdt*dt
#         
#         if I[i]>I[i-1]:
#             posttimer=False
#             
#         if aptimer != np.inf:
#             aptimer-=1
#         if v[i-1]>vth[dnum]:
#             v[i]=vbr[dnum] # vb[dnum]
#             apinds.append(i)
#             aptimer=refper
#             posttimer=True
#         if aptimer==0:
#             aptimer=np.inf
# # =============================================================================
# #     # Comment out
# #     fig,ax=plt.subplots(2,1)
# #     ax[0].plot(Iext)
# #     ax[1].plot(range(len(vd)), v)
# # =============================================================================
#     aptimes=np.array(apinds)*dt
#     ssaptimes=aptimes[int(0.3*len(aptimes)):]
#     tmean = np.mean(np.diff(ssaptimes))
#     return v, tmean
# 
# # 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# # 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4
# 
# dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
# #                0   1   2   3   4    5     6      7    8   9  10  11
# vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
# #                0   1   2   3   4    5     6       7    8   9     10    11
# vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
# #    0        1           2          3        4         5
# C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
#    0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
# #    6        7          8        9          10       11
# #    0        1           2          3        4         5
# Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
#    0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
# #    6        7          8        9          10       11
# #    0        1          2      3        4        5
# g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
#    0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
# #    6        7       8        9       10       11
# #    0        1          2      3        4        5
# gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
#    0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
# #    6        7       8        9       10       11
# #     0    1    2     3    4    5    6    7    8   9    10   11
# vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]
# 
# # Parameters
# 
# sfreq = 20 # Hz
# runtime_sec = 1 # total runtime in seconds
# runtime = int(runtime_sec / dt)  # number of simulation steps
# 
# y0 = 1300
# taui = 0.001
# tauy = 0.0025
# kiy = 1
# 
# r=1
# Iext = getiext(sfreq, runtime, y0, taui, tauy, kiy, dt)
# 
# # =============================================================================
# # # Plot
# # fs=15
# # v, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
# # fig, ax = plt.subplots(2,1, figsize=(6,4))
# # ax[0].plot(np.arange(len(Iext)), Iext, label = 'Iext')
# # ax[0].set_xticks([])
# # ax[0].set_ylabel('Input\ncurrent', fontsize=fs)
# # ax[0].tick_params(axis='both', labelsize=fs)
# # # =============================================================================
# # # ax[0].plot(np.arange(len(I)), I, label='I')
# # # =============================================================================
# # ax[1].plot(np.arange(len(Iext)), v, color='k')
# # ax[1].set_xlabel('Time (ms)', fontsize=fs)
# # ax[1].set_ylabel('Membrane\npotential', fontsize=fs)
# # ax[1].tick_params(axis='both', labelsize=fs)
# # plt.show()
# # #%%
# # =============================================================================
# 
# # =============================================================================
# # gettmean(0.1, I, g, vb, dnum, C, Cr)
# # #%%
# # =============================================================================
# 
# rlist=np.linspace(0,1,100)
# tlist=[]
# for i,r in enumerate(rlist):
#     print(i, len(rlist))
#     _, tmean=gettmean(r, Iext, g, vb, dnum, C, Cr)
#     tlist.append(tmean)
# foutlist=1/np.array(tlist)
# 
# fs=15
# plt.plot(rlist, foutlist)
# plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
# plt.ylabel('Output frequency (Hz)', fontsize=fs)
# # =============================================================================
# # plt.ylim([0, np.max(foutlist)])
# # =============================================================================
# plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(sfreq))
# plt.legend(fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.show()
# 
# # =============================================================================
# # rlist2=[0, 0.25, 0.5, 0.75, 1]
# # flist=np.linspace(1,100,100)
# # foutlist=[]
# # for i,r in enumerate(rlist2):
# #     print(i, len(rlist2))
# #     tlist=[]
# #     for j, sfreq in enumerate(flist):
# #         print(i, len(rlist2), j, len(flist))
# #         Iext=getiext(sfreq, 10, y0, taui, tauy, kiy, dt)
# #         _, tmean = gettmean(r, Iext, g, vb, dnum, C, Cr)
# #         tlist.append(tmean)
# #     fout=1/np.array(tlist)  
# #     foutlist.append(fout)
# #     
# # for i,fout in enumerate(foutlist):
# #     plt.plot(flist, fout, label='r={}'.format(np.around(rlist2[i],2)))
# #     
# # plt.legend()
# # plt.xlabel('Input frequency (Hz)')
# # plt.ylabel('Output frequency (Hz)')
# # plt.show()
# # =============================================================================
# =============================================================================

#%% 9th - Ratio 2 with increasing inputs -- GOOD

def fit_line(times, points):
    """
    Fits a line y = mx + b to the given points and times.

    Parameters:
    times (array-like): x-values (e.g., time)
    points (array-like): y-values (e.g., observed data)

    Returns:
    tuple: (m, b) where y = mx + b
    """
    times = np.asarray(times)
    points = np.asarray(points)
    
    if len(times) != len(points):
        raise ValueError("times and points must have the same length.")
    
    m, b = np.polyfit(times, points, 1)
    return m, b

def getiext(sfreq, taui, tauy, kiy, dt, r):
    
    pretimes = [int(i/sfreq/dt) for i in range(0,10)]
    presizes = np.linspace(1, sfreq*(1-r)*0.05+2, len(pretimes))

    m,b=fit_line(pretimes, presizes)

    extra=100
    runtime = pretimes[-1]+extra
    Iext = np.zeros(runtime)
    y = np.zeros(runtime)
    # Time evolution
    j=0
    for i in range(0, runtime):
        if i in pretimes:
            y[i-1] = presizes[j]  # reset just before update
            j+=1

        dy = -y[i-1] / tauy
        y[i] = y[i-1] + dy * dt

        dIext = -Iext[i-1] / taui + kiy * y[i-1]
        Iext[i] = Iext[i-1] + dIext * dt
    return Iext, y, m, b, runtime

# =============================================================================
# def getiext2(sfreq, taui, tauy, kiy, dt, r):
#     
#     pretimes = [int(i/sfreq/dt) for i in range(0,10)]
#     
#     extra=100
#     runtime = pretimes[-1]+extra
#     
#     a=5000
#     b=500
#     Tmax=9/sfreq
#     slope=a*sfreq*(1-r)+b*sfreq*r
#     const=1
#     yline=slope*np.linspace(0, Tmax*dt, runtime)+const
#     plt.plot(yline)
#     
#     
#     Iext = np.zeros(runtime)
#     y = np.zeros(runtime)
#     # Time evolution
#     for i in range(0, runtime):
#         if i in pretimes:
#             y[i-1] = yline[i]  # reset just before update
# 
#         dy = -y[i-1] / tauy
#         y[i] = y[i-1] + dy * dt
# 
#         dIext = -Iext[i-1] / taui + kiy * y[i-1]
#         Iext[i] = Iext[i-1] + dIext * dt
# 
# # =============================================================================
# #     Iext = 1*np.ones(int(1/dt))
# # =============================================================================
#     return Iext, y, yline, slope, const
# 
# =============================================================================

def getiext3(sfreq, taui, tauy, dt, r):
    
    pretimes = [int(i/sfreq/dt) for i in range(0,10)]
    extra=100
    runtime = pretimes[-1]+extra
    
    a=2000
    b=500
    Tmax=9/sfreq
    slope=a*sfreq*(1-r)+b*sfreq*r
    const=1
    presizes=slope*np.linspace(0, Tmax*dt, runtime)+const

    Iext = np.zeros(runtime)
    # Time evolution
    j=0
    for i in range(0, runtime):
        dIext = -Iext[i-1] / taui 
        Iext[i] = Iext[i-1] + dIext * dt
        if i in pretimes:
            print(presizes[i])
            Iext[i] = presizes[i]  # reset just before update
            j+=1
    return Iext, runtime, presizes, slope, const, 

sfreq = 40 # Hz
taui = 0.001
tauy = 0.0025
r=1

Iext, runtime, presizes, slope, const = getiext3(sfreq, taui, tauy, dt, r)

plt.plot(Iext)
plt.plot(presizes)

#%%
# =============================================================================
# sfreq = 100 # Hz
# taui = 0.001
# tauy = 0.0025
# kiy = 100
# r=0
# Iext,y,yline = getiext2(sfreq, taui, tauy, kiy, dt, r)
# 
# fig,ax=plt.subplots(2,1)
# ax[0].plot(np.linspace(0,len(yline)*dt,len(yline)),Iext)
# ax[1].plot(np.linspace(0,len(yline)*dt,len(yline)),y)
# ax[1].plot(np.linspace(0,len(yline)*dt,len(yline)),yline)
# plt.show()
# 
# #%%
# =============================================================================

def gettmean(r, I, g, vb, dnum, C, Cr):
    v=np.zeros(len(I))
    v[0]=vd[0]
    apinds=[]
    refper=40
    aptimer=np.inf
    posttimer=False
    for i in range(1,len(I)):

        if posttimer==False:
            icurr = r*g[7]*(v[i-1]-vb[dnum])+(1-r)*g[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/C[dnum]
        if posttimer==True:
            icurr = r*gr[7]*(v[i-1]-vb[dnum])+(1-r)*gr[11]*(v[i-1]-vb[dnum])
            dvdt=((-icurr+Iext[i-1]))/Cr[dnum]

        if aptimer != np.inf:
            v[i] = v[i-1]
        else:
            v[i] = v[i-1]+dvdt*dt

        if I[i]>I[i-1]:
            posttimer=False

        if aptimer != np.inf:
            aptimer-=1
        if v[i-1]>vth[dnum]:
            v[i]=vbr[dnum] # vb[dnum]
            apinds.append(i)
            aptimer=refper
            posttimer=True
        if aptimer==0:
            aptimer=np.inf
# =============================================================================
#     # Comment out
#     fig,ax=plt.subplots(2,1)
#     ax[0].plot(Iext)
#     ax[1].plot(range(len(vd)), v)
# =============================================================================
    aptimes=np.array(apinds)*dt
    naps=len(aptimes)
    ssaptimes=aptimes[int(0.3*len(aptimes)):]
    tmean = np.mean(np.diff(ssaptimes))
    return v, tmean, naps, aptimes

# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4,
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

dt=0.1e-3                                # 8 is (6,10) and 9 is (7,11)
#                0   1   2   3   4    5     6      7    8   9  10  11
vb=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-63,-64,-65.5,-64,-63.8])
#                0   1   2   3   4    5     6       7    8   9     10    11
vbr=np.array([-60.5,-60,-60,-60,-64.2,-64.2,-61.75,-50,-50,-47,-64,-50])
#    0        1           2          3        4         5
C=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.000111]
#    6        7          8        9          10       11
#    0        1           2          3        4         5
Cr=[0.00011,  0.00011,  0.00011,  0.00011,  0.00011,  0.00011,
   0.00009, 0.0001,  0.00011,  0.00011,  0.00011, 0.0001]
#    6        7          8        9          10       11
#    0        1          2      3        4        5
g=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.0037,  0.0037,  0.0037,  0.0037, 0.003]
#    6        7       8        9       10       11
#    0        1          2      3        4        5
gr=[0.0037,  0.0037,  0.0037,  0.0037,  0.0037,  0.0037,
   0.0035, 0.004,  0.0037,  0.0037,  0.0037, 0.005]
#    6        7       8        9       10       11
#     0    1    2     3    4    5    6    7    8   9    10   11
vth=[-40, -40, -40, -40, -40, -40, -40, -40, -41, -40, -40, -39]

# Parameters
sfreq = 40 # Hz
taui = 0.001
tauy = 0.0025
kiy = 500

# =============================================================================
# r=1
# Iext, ytest, mtest, btest = getiext(sfreq, taui, tauy, kiy, dt,r)
# plt.plot(ytest)
# plt.plot(np.linspace(0, len(Iext), len(Iext))*mtest+btest)
# #%%
# =============================================================================

# =============================================================================
# def shift_forward(arr, n):
#     """
#     Shift the array forward (right) by n indices and remove the last n elements.
#     The result has the same length as the input array.
#     
#     Parameters:
#     arr (np.ndarray): 1D input array.
#     n (int): Number of indices to shift.
# 
#     Returns:
#     np.ndarray: Shifted array.
#     """
#     if n <= 0:
#         return arr.copy()
#     elif n >= len(arr):
#         return np.zeros_like(arr)
#     else:
#         return np.concatenate((np.zeros(n, dtype=arr.dtype), arr[:-n]))
# =============================================================================
    
# =============================================================================
# plt.plot(Iext)
# #%%
# =============================================================================
# 0-DF1, 1-DF4, 2-DM1, 3-DM4, 4-DS1, 5-DS4, 
# 6-NF1, 7-NF4, 8-NM1, 9-NM4, 10-NS1, 11-NS4

# =============================================================================
#
## Get the real current data slope
#
# dnum= 10 # <----------------------------------- neuron number
# dsize= 'z' # f full, z zoomed
# dsnum= 1 if dnum in [0, 2, 4,6,8,10] else 0
# dlens=[4000,12000]
# if dsize=='f':
#     I=data[:, dnum]
# if dsize=='z':
#     I=data[:, dnum][:dlens[dsnum]]
# # Processing the data
# I = 25*I
# from scipy.signal import find_peaks
# peaks, _ = find_peaks(I)
# peakvals=I[peaks]
# peakratio=(peakvals[-1]-peakvals[0])/(peaks[-1]-peaks[0])/dt
# maxmin=peakvals[-1]/peakvals[0]
# print(peakratio)
# print(maxmin)
# plt.plot(np.linspace(0,len(I)*dt,len(I)),I, label='data')
# plt.title('{}'.format(names[dnum]), fontsize=fs)
# # =============================================================================
# # plt.plot(Iext, label='Iext')
# # =============================================================================
# b=(peakvals[-1]*peaks[0]-peakvals[0]*peaks[-1])/(peaks[0]-peaks[-1])
# y=peakratio*np.linspace(0,10000*dt, 10000)+b
# plt.plot(np.linspace(0,len(y)*dt,len(y)),y, label='y={}x+{}'.format(np.around(peakratio,2), np.around(b,2)))
# # =============================================================================
# # plt.text(200, peakvals[3], 'y={}x+{}'.format(np.around(peakratio,2), np.around(b,2)))
# # plt.text(200, peakvals[-4], 'max peak / min peak = {}'.format(np.around(maxmin,3)))
# # =============================================================================
# plt.plot([],[], ' ', label=' peak max/min = {}'.format(np.around(maxmin,3) ))
# plt.xlabel('Time (sec)', fontsize=fs)
# plt.ylabel('Current', fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.legend(fontsize=fs-4, loc='upper left')
# plt.show()
# #%%
# 
# =============================================================================
def getline(Iext):
    peaks, _ = find_peaks(Iext)
    peakvals=Iext[peaks]
    peakratio=(peakvals[-1]-peakvals[0])/(peaks[-1]-peaks[0])/dt
    maxmin=peakvals[-1]/peakvals[0]
    print(peakratio)
    print(maxmin)
    b=(peakvals[-1]*peaks[0]-peakvals[0]*peaks[-1])/(peaks[0]-peaks[-1])
    y=peakratio*np.linspace(0,len(Iext)*dt, len(Iext))+b
    return y, peakratio, b

# Plot
r=0
sfreq=40
# Iext, yi, mi, bi, runtime = getiext(sfreq, taui, tauy, kiy, dt,r)
# Iext, yi, yiline, slope, const = getiext2(sfreq, taui, tauy, kiy, dt, r)
Iext, runtime, presizes, slope, const = getiext3(sfreq, taui, tauy, dt, r)
y, peakratioy, by = getline(Iext)

yiline, peakratioyi, byi=getline(yi)

v, tmeantest, naps, aps = gettmean(r, Iext, g, vb, dnum, C, Cr)

fs=15
fig, ax = plt.subplots(2, 1, figsize=(6, 5))

tarr=np.linspace(0, len(Iext)*dt, len(Iext))
ax[0].plot(tarr, Iext)
ax[0].tick_params(axis='both', labelsize=fs)
ax[0].set_ylabel('y input\nfor spikes', fontsize=fs)
ax[0].set_xticks([])
ax[0].legend(fontsize=fs-3, loc='upper left')

ax[1].plot(tarr, v)
#%%
ax[0].plot()
# Originally ax[2] -> now ax[0]
ax[0].plot(tarr, yi, label='ysim') # y plot
ax[1].plot(np.linspace(0, len(Iext)*dt, len(Iext)), #input
            slope*np.linspace(0, len(Iext)*dt, len(Iext))+const,
            # yiline, #output
           color='r', # Red line <----------------
           label='y=f(0.05f(1-r)+2)t/9+1, y={} x + {}'.format(
               np.around(peakratioyi,2), np.around(byi,2)))
# =============================================================================
# ax[0].plot(np.linspace(0, len(Iext)*dt, len(Iext)), 
#            # sfreq*(0.05*sfreq*(1-r)+r)/9*np.linspace(0,9/sfreq,len(Iext))+1, 
#            slope*np.linspace(0, len(Iext)*dt, len(Iext))+const,
#            color='k',
#            label='{}t + {}'.format(np.around(slope,2), 
#                                             np.around(const,2)))
# =============================================================================
ax[0].tick_params(axis='both', labelsize=fs)
ax[0].set_ylabel('y input\nfor spikes', fontsize=fs)
ax[0].set_xticks([])
ax[0].legend(fontsize=fs-3, loc='upper left')

# Originally ax[0] -> now ax[1]
ax[1].plot(np.linspace(0, len(Iext)*dt, len(Iext)), Iext, color='orange', 
           label='current: 10 injections @ {} Hz, r={}'.format(sfreq, r))
ax[1].set_xticks([])
ax[1].set_ylabel('Input\ncurrent', fontsize=fs)
ax[1].tick_params(axis='both', labelsize=fs)
ax[1].plot(np.linspace(0, len(y)*dt, len(y)), y, 
           label='y={}t+{}'.format(np.around(peakratioy, 2), np.around(by, 2)), 
           color='g')
ax[1].legend(loc='upper left', fontsize=fs-3)

# Originally ax[1] -> now ax[2]
ax[2].plot(np.linspace(0, len(Iext)*dt, len(Iext)), v)
ax[2].set_xlabel('Time (sec)', fontsize=fs)
ax[2].set_ylabel('Membrane\npotential', fontsize=fs)
ax[2].tick_params(axis='both', labelsize=fs)
ax[2].plot(np.linspace(0, len(Iext)*dt, len(Iext)), vth[dnum]*np.ones(len(Iext)), 
           color='k')
ax[2].scatter(aps, vth[dnum]*np.ones(len(aps)), color='r', s=200, marker='x', zorder=2)
ax[2].plot([], [], ' ', label='Output = {} Hz, #APs={}'.format(np.around(1/tmeantest), naps))
ax[2].legend(loc='upper left', handlelength=1, fontsize=fs-3)
ax[2].set_ylim([-67, -26])
# ax[2].text(0.225, -35, 'AP', fontsize=fs)
ax[2].set_xlabel('Time (sec)', fontsize=fs)

plt.show()


#%%

# =============================================================================
# gettmean(0.1, I, g, vb, dnum, C, Cr)
# #%%
# =============================================================================

# Fix fin plot
sfreq=100
rlist=np.linspace(0,1,100)
tlist=[]
rateslist=[]
napslist=[]
for i,r in enumerate(rlist):
    print(i, len(rlist))
    Iext, _, _, _, runtime = getiext(sfreq, taui, tauy, kiy, dt, r)
    _, tmean, naps, _ = gettmean(r, Iext, g, vb, dnum, C, Cr)
    rateslist.append(naps/runtime/dt)
    tlist.append(tmean)
    napslist.append(naps)
foutlist=1/np.array(tlist)

fs=15
plt.plot(rlist, foutlist)
plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
plt.ylabel('Output frequency (Hz)', fontsize=fs)
# =============================================================================
# plt.ylim([0, np.max(foutlist)])
# =============================================================================
plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(sfreq))
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.show()

# =============================================================================
# fs=15
# plt.plot(rlist, rateslist)
# plt.xlabel('Percentage of fast SOM synapses', fontsize=fs)
# plt.ylabel('Output rates (Hz)', fontsize=fs)
# # =============================================================================
# # plt.ylim([0, np.max(foutlist)])
# # =============================================================================
# plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(sfreq))
# plt.legend(fontsize=fs)
# plt.tick_params(axis='both', labelsize=fs)
# plt.show()
# =============================================================================

#naps
fs=15
plt.plot(rlist, napslist)
plt.xlabel('Proprtion of fast synapses', fontsize=fs)
plt.ylabel('# of APs', fontsize=fs)
# =============================================================================
# plt.ylim([0, np.max(foutlist)])
# =============================================================================
plt.plot([], [], ' ', label='Input frequency = {} Hz'.format(sfreq))
plt.legend(fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.show()

# =============================================================================
# # fix r plot
# rlist2=[0, 0.25, 0.5, 0.75, 1]
# flist=np.linspace(1,100,100)
# foutlist=[]
# for i,r in enumerate(rlist2):
#     print(i, len(rlist2))
#     tlist=[]
#     for j, sfreq in enumerate(flist):
#         print(i, len(rlist2), j, len(flist))
#         Iext=getiext(sfreq, y0, taui, tauy, kiy, dt,r)
#         _, tmean = gettmean(r, Iext, g, vb, dnum, C, Cr)
#         tlist.append(tmean)
#     fout=1/np.array(tlist)  
#     foutlist.append(fout)
#     
# for i,fout in enumerate(foutlist):
#     plt.plot(flist, fout, label='r={}'.format(np.around(rlist2[i],2)))
#     
# plt.legend()
# plt.xlabel('Input frequency (Hz)')
# plt.ylabel('Output frequency (Hz)')
# plt.show()
# =============================================================================
