from tqdm import tqdm
from scipy.optimize import minimize
import numpy as np
from matplotlib.pyplot import plot as pt
import matplotlib.pyplot as plt
from numpy.random import exponential, binomial, gamma
from numpy import exp
from numpy import sqrt as Sqrt
from numpy import log as Log
import pandas as pd
from numba import jit
import os
import re

# @jit(nopython=True)
def sim(V0, tlen, Iext, dt, vr, rf, gL, vt, C_m):
    
    # Variables initialization
    V = np.zeros(tlen)
    aplist = np.zeros_like(V)

    # Set initial conditions
    V[0] = V0

    ratio = 0.3
    rfon = False
    rftimer = np.inf
    
    for i in range(1, tlen):

        i_ion = gL*(V[i-1]-V0)

        dVdt = (1 / C_m) * (Iext[i-1]-i_ion)
        V[i] = V[i-1] + dVdt * dt*(1-rfon)

        if rftimer != np.inf:
            rftimer -= dt

        if rftimer <= 0:
            rftimer = np.inf
            rfon = False

        if V[i] > vt:  # AP
            if i > int(ratio*tlen) and i < tlen:
                aplist[i] = i*dt
            rfon = True
            rftimer = rf
            V[i] = vr

    aps = getaps(aplist, dt)
    if len(aps) < 2:
        fout = 0.0  # or np.nan if you want to flag it
    else:
        fout = 1/np.mean(np.diff(aps))
    return V, fout

# @jit(nopython=True)
def getaps(aplist, dt):
    return np.where(aplist != 0)[0]*dt

file = r'C:\Users\Oliver\Desktop\Research\PYR\PYR model data'
files=['F-I.csv', 'firing_frequencies.csv', 'VT csv', 'VT NOISE']


data=pd.read_csv(file+'\{}'.format(files[0]))
data=np.array(data.iloc[:, :2])
data[:,0]*=1e-9

tmax = 1.5  # <----------------- TMAX
dt = 1e-4
rf = 1e-3  # refractory period

V0 = -70e-3  # initial membrane potential (mV)
C_m = 200e-12
vr = V0
gL = 15e-9  # leak conductance nS
vt = -50e-3  # threshold base value at no activity
A=0.1e-9 # current amplitude

# =============================================================================
# Iext = np.zeros(int(tmax/dt))
# Iext[int(tmax/dt*0.2):int(tmax/dt*0.6)]=A
# res=sim(V0, len(Iext), Iext, dt, vr, rf, gL, vt, C_m)
# t=np.linspace(0,len(Iext),len(Iext))*dt
# 
# plt.subplot(3,1,1)
# plt.plot(t, Iext)
# plt.xticks([])
# 
# plt.subplot(3,1,2)
# plt.plot(t, res[0])
# plt.xticks([])
# =============================================================================

# plt.subplot(3,1,3)
alist=data[:,0]
fouts=[]
for a in alist:
    Iext = np.zeros(int(tmax/dt))
    Iext[int(tmax/dt*0.2):int(tmax/dt*0.6)]=a
    res=sim(V0, len(Iext), Iext, dt, vr, rf, gL, vt, C_m)
    fouts.append(res[1])
    
    
plt.plot(alist, data[:, 1], label='experimental')
plt.plot(alist, fouts, label='simulation')
# =============================================================================
# plt.plot(alist, data[:, 1], label='experimental', 
#             marker='o')
# plt.plot(alist, fouts, label='simulation', 
#          linewidth=1, alpha=0.8, marker='o')
# =============================================================================

plt.ylabel('Output frequency')
plt.legend()
plt.show()
