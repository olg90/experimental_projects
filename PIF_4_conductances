#%% Define the functions for fitting
import numpy as np
from matplotlib.pyplot import plot as pt
import matplotlib.pyplot as plt
from numpy.random import exponential, binomial, gamma
from numpy import exp
from numpy import sqrt as Sqrt
from numpy import log as Log
import pandas as pd
from numba import jit

def getiext(f, y0, tauy, taui, ki, tmax, dt):
    
        tlist=[]
        ylist=[]
        Iextlist=[]

        Iext=0
        y=0

        tcurr=0
        timer = dt
        e=1e-6
        while tcurr < tmax:
            t0=np.random.exponential(1/(f+e)) # action potential
            t1 = timer
            
            if t0 < t1:
                y += y0
                tmin=t0
                timer-=tmin
            else:
                Iextlist.append(Iext)
                ylist.append(y)
                tlist.append(tcurr)
                timer=dt
                tmin=timer
            tcurr += tmin

            # Update the continuous dynamics
            Iext += (-Iext/taui + ki*y)*tmin
            y += (-y/tauy)*tmin
            
        return np.array(tlist), np.array(ylist), np.array(Iextlist)

def getcurrents(f, fi, y0e, y0i, tauye, tauyi, tauie, tauii, kie, kii, tmax, dt):
    # Get the currents
    tlisti, yi, iext = getiext(fi, y0i, tauyi, tauii, kii, tmax, dt)
    tliste, ye, eext = getiext(f, y0e, tauye, tauie, kie, tmax, dt)
    # Make them the same size
    llist=[len(tlisti), len(tliste)]
    largmin=np.argmin(llist)
    if largmin==0:
        tliste = tliste[:llist[largmin]]
        eext = eext[:llist[largmin]]
    else:
        tlisti = tlisti[:llist[largmin]]
        iext = iext[:llist[largmin]]
    return tlisti, tliste, iext, eext, yi, ye

def getstats(aplist):

    aps = [apind*dt for apind in aplist if apind!=0]
    
    tdiffs=np.diff(aps)
    
    tmean=np.mean(tdiffs)
    var=np.var(tdiffs)
    cv=var/tmean**2
    
    return tmean, var, cv

def getaps(aplist, dt):
    return np.where(aplist!=0)[0]*dt

@jit(nopython=True)
def thetainf(vm, vi, vt, at):
    if vm < vi:
        return vt
    else:
        return at*(vm-vi)+vt
    
def gspikes(Gexc, Ginh, args):
    for x in args:
        if x[3]==1:
            Gexc[x[0]:x[0]+x[1]]=x[2]
        if x[3]==-1:
            Ginh[x[0]:x[0]+x[1]]=x[2]
    return Gexc, Ginh


@jit(nopython=True)
def rinf(V):
    # value = 76 # original
    value = 77 # slightly better subthreshold fit
    return (1 + exp((V + value) / 7))**(-1)

# KLVT, original ------------------------------------------------------------------------------------------------ Make these slower
# low threshold potassium current, hyperpolarize when subthreshold polarized 
@jit(nopython=True) 
def winf(V):#1            48    6 ------------------------------------------------------------------- (CHANGED HERE)
    return (1 + exp(-(V + 48) / 6))**(-1 / 4)
@jit(nopython=True) # low threshold potassium current KLT
def zinf(V):
    zeta = 0.5 #0.5                           71    10 ------------------------------------------------------------------- (CHANGED HERE)
    return (1 - zeta)*(1 + exp((V + 100) / 10))**(-1) + zeta

@jit(nopython=True)
#            v - better at 1000                                                                    shift hmp lft
def tauw(V): #100  6          60      6    16*0.2            60    45           1.5
    return (100 * (6 * exp((V+ 60) / 6) + 16*0.2 * exp(-(V + 60) / 45))**(-1) + 1.5)*1e-3
@jit(nopython=True)
def tauz(V):# 1000          60    20    0.2           60    8           50
    return (1000 * (exp((V + 60) / 20) + 0.2*exp(-(V + 60) / 8))**(-1) + 50)*1e-3
# END CHANGE ---------------------------------------------------------------------------------------- End change

@jit(nopython=True)
def taur(V): #10**5  237            60    12    17             60    14           25
    return (10**5 * (237 * exp((V + 60) / 12) + 17 * exp(-(V + 60) / 14))**(-1) + 25)*1e-3

@jit(nopython=True)
def simulate(vlen, V0, w0, z0, r0, Gexc, Ginh, gLT, gh, VK, Vh, q10, dt,
             vi, vt, at, vr, glk, Vlk, rf):

    # Time vector
    t = np.linspace(0, vlen, vlen)
    
    # Variables initialization
    V = np.zeros(vlen)
    w = np.zeros(vlen)
    z = np.zeros(vlen)
    r = np.zeros(vlen)
    
    iLT = np.zeros(vlen)
    ih = np.zeros(vlen)
    ilk = np.zeros(vlen)
    iexc = np.zeros(vlen)
    iinh = np.zeros(vlen)
    
    theta=np.zeros(vlen)
    theta1=np.zeros_like(theta)
    theta2=np.zeros_like(theta)
    aplist=np.zeros_like(theta)
    
    # Set initial conditions
    V[0] = V0
    w[0] = w0 # Low threshold K+ current
    z[0] = z0
    r[0] = r0 # Leak current
    theta1[0]=vt
    theta[0]=vt
    
    rfon=False
    rftimer = np.inf
    
    for i in range(1, vlen):
        # Get all the current and voltage values and update the voltage
        i_LT = gLT * w[i-1]**4 * z[i-1] * (V[i-1] - VK)
        i_h = gh * r[i-1] * (V[i-1] - Vh)  # something weird
        i_lk = glk * (V[i-1] - Vlk)
        i_exc = Gexc[i-1]*V[i-1]
        i_inh = Ginh[i-1]*V[i-1]

        dVdt = -(1 / C_m) * (i_LT + i_h + i_lk +i_exc-i_inh)
        # dVdt = -(1 / C_m) * (i_LT + i_h +i_exc-i_inh)
        V[i] = V[i-1] + dVdt * dt*(1-rfon)

        # Add all the current values to a list for plotting
        iLT[i] = i_LT
        ih[i] = i_h
        iexc[i] = i_exc
        iinh[i] = i_inh
        ilk[i]=i_lk

        # Add the current value of each gating variable to a list containing
        # all the previous values, for plotting
        vprev = V[i-1] * 1e3
        w[i] = w[i-1] + ((winf(vprev) - w[i-1]) / tauw(vprev)) * dt * q10
        z[i] = z[i-1] + ((zinf(vprev) - z[i-1]) / tauz(vprev)) * dt * q10
        r[i] = r[i-1] + ((rinf(vprev) - r[i-1]) / taur(vprev)) * dt * q10
        
        # Thresholds
        dtheta1dt = 1/tautheta1*(-theta1[i-1] + thetainf(V[i-1], vi, vt, at))
        theta1[i] = theta1[i-1] + dtheta1dt*dt
        dtheta2dt=1/tautheta2*(-theta2[i-1])
        theta2[i]=theta2[i-1]+dtheta2dt*dt
        theta[i] = theta1[i]+theta2[i]
        
        if rftimer!=np.inf:
            rftimer-=dt
            
        if rftimer<=0:
            rftimer=np.inf
            rfon=False
        
        if V[i]>theta[i]:
            theta2[i]+=alpha
            V[i]=vr
            aplist[i]=i*dt
            rfon=True
            rftimer=rf
            
    return V, t, w, z, r, iLT, ih, ilk, iexc, iinh, theta, aplist




# Main code -------------------------------------------------------------------

# Conductance generation
f=20 # exc
fi=20 # inh
y0e=1 # synthetic spiking variable amplitude
y0i=1
tauye=0.1 # decay rate of synthetic spiking variable
tauyi=0.1
tauie=0.01 # current decay rate
tauii=0.01
kie=3e-6 # convert trom y to I
kii=1e-6

# Threshold Lubejko parameters
tautheta1=25e-3
tautheta2=50e-3
vr=-62e-3
vi=-45e-3
vt=-31e-3
at=0.8
alpha=50e-3
rf=100e-3

# Conductance model parameters
gLT = 50e-9 # 50e-9 # X <---------------- #200e-9
gh = 100e-9  # 100e-9 # X <---------------- # 20e-9, 11e-9
glk = 5e-9  # Leakage conductance
VK = -80e-3  # potassium reverse potential
Vh = -43e-3  # hyperpolarizing reverse potential
Vlk = -65e-3  # leakage reverse potential
V0 = -60e-3  # initial membrane potential (mV)
w0 = 0.594  # Low-threshold K+ current
z0 = 0.608  # Low-threshold K+ current
r0 = 0.063  # Hyperpolarization current
C_m = 12e-12  # membrane capacitance (uF/cm^2)
q10=(3**((37-22)/10)) # heat parameter

# Simulation parameters
tmax=6
dt=1e-5

tlisti, tliste, Ginh, Gexc, yi, ye = getcurrents(f, fi, y0e, y0i, tauye, tauyi, 
                                         tauie, tauii, kie, kii, tmax, 
                                         dt)
# =============================================================================
# # Testing currents
# Ginh=0*Ginh
# Gexc=0*Gexc
# # Gexc[500:1200]=30e-9#*np.linspace(0,(end-st)*dt, end-st)
# Gexc, Ginh =gspikes(Gexc, Ginh, [
#                          [500,700,30e-9,1], 
#                          [1500,500,10e-9,-1],
#                          [2500,500,30e-9,1],
#                          [2500,500,30e-9,1],
#                          [3500,500,10e-9,-1],
#                          [4050,500,30e-9,1]])
# =============================================================================

vlen=len(tliste)
V, t, w, z, r, iLT, ih, ilk, iexc, iinh, theta, aplist\
    =simulate(vlen, V0, w0, z0, r0, Gexc, Ginh, gLT, gh, 
              VK, Vh, q10, dt, vi, vt, at, vr, glk, Vlk, rf)
aps=getaps(aplist, dt)

fs = 15
plt.subplot(3, 1, 1)
plt.plot(tliste, Gexc, label='Ge {} Hz'.format(f))
plt.plot(tliste, Ginh, label='Gi {} Hz'.format(fi))
plt.ylabel('Conductance', fontsize=fs)
plt.xticks([], fontsize=fs)
plt.yticks(fontsize=fs)
plt.legend(loc='upper right', fontsize=fs)

plt.subplot(3, 1, 2)
plt.plot(tlisti, iLT, label='iLT')
plt.plot(tlisti, ih, label='iH')
plt.plot(tlisti, ilk, label='iLK')
plt.ylabel('Current', fontsize=fs)
plt.xticks([], fontsize=fs)
plt.yticks(fontsize=fs)
plt.legend(loc='upper right', fontsize=fs)

plt.subplot(3, 1, 3)
plt.plot(t * dt, V * 1000, label='V')
plt.plot(t * dt, vr * 1000 * np.ones(len(t)), linestyle='-', color='gray', alpha=0.5, label='vr')
plt.plot(t * dt, vi * 1000 * np.ones(len(t)), linestyle='--', color='gray', alpha=0.5, label='vi')
plt.plot(t * dt, theta * 1000 * np.ones(len(t)), linestyle='-', color='k', alpha=1, label='vth')
plt.ylabel('Membrane\npotential (mV)', fontsize=fs)
plt.xlabel('Time (sec)', fontsize=fs)
plt.yticks(fontsize=fs)
plt.xticks(fontsize=fs)
plt.legend(loc='upper right', fontsize=fs)
for x in aps:
    plt.axvline(x, color='r', alpha=0.6)
plt.show()

