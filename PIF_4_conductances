#%% Define the functions for fitting
import numpy as np
from matplotlib.pyplot import plot as pt
import matplotlib.pyplot as plt
from numpy.random import exponential, binomial, gamma
from numpy import exp
from numpy import sqrt as Sqrt
from numpy import log as Log
import pandas as pd
from numba import jit

def getiext(f, y0, tauy, taui, ki, tmax, delta_t):
    
        tlist=[]
        ylist=[]
        Iextlist=[]

        Iext=0
        y=0

        tcurr=0
        timer = delta_t
        e=1e-6
        while tcurr < tmax:
            t0=np.random.exponential(1/(f+e)) # action potential
            t1 = timer
            
            if t0 < t1:
                y += y0
                tmin=t0
                timer-=tmin
            else:
                Iextlist.append(Iext)
                ylist.append(y)
                tlist.append(tcurr)
                timer=delta_t
                tmin=timer

            tcurr += tmin

            # Update the continuous dynamics
            Iext += (-Iext/taui + ki*y)*tmin
            y += (-y/tauy)*tmin
            
        return np.array(tlist), np.array(ylist), np.array(Iextlist)

def getcurrents(f, fi, y0e, y0i, tauye, tauyi, tauie, tauii, kie, kii, tmax, delta_t):
    # Get the currents
    tlisti, yi, iext = getiext(fi, y0i, tauyi, tauii, kii, tmax, delta_t)
    tliste, ye, eext = getiext(f, y0e, tauye, tauie, kie, tmax, delta_t)
    # Make them the same size
    llist=[len(tlisti), len(tliste)]
    largmin=np.argmin(llist)
    if largmin==0:
        tliste = tliste[:llist[largmin]]
        eext = eext[:llist[largmin]]
    else:
        tlisti = tlisti[:llist[largmin]]
        iext = iext[:llist[largmin]]
    return tlisti, tliste, iext, eext, yi, ye

@jit(nopython=True)
def rinf(V):
    # value = 76 # original
    value = 77 # slightly better subthreshold fit
    return (1 + exp((V + value) / 7))**(-1)

# KLVT, original ------------------------------------------------------------------------------------------------ Make these slower
# low threshold potassium current, hyperpolarize when subthreshold polarized 
@jit(nopython=True) 
def winf(V):#1            48    6 ------------------------------------------------------------------- (CHANGED HERE)
    return (1 + exp(-(V + 48) / 6))**(-1 / 4)
@jit(nopython=True) # low threshold potassium current KLT
def zinf(V):
    zeta = 0.5 #0.5                           71    10 ------------------------------------------------------------------- (CHANGED HERE)
    return (1 - zeta)*(1 + exp((V + 100) / 10))**(-1) + zeta

@jit(nopython=True)
#            v - better at 1000                                                                    shift hmp lft
def tauw(V): #100  6          60      6    16*0.2            60    45           1.5
    return (100 * (6 * exp((V+ 60) / 6) + 16*0.2 * exp(-(V + 60) / 45))**(-1) + 1.5)*1e-3
@jit(nopython=True)
def tauz(V):# 1000          60    20    0.2           60    8           50
    return (1000 * (exp((V + 60) / 20) + 0.2*exp(-(V + 60) / 8))**(-1) + 50)*1e-3
# END CHANGE ---------------------------------------------------------------------------------------- End change

@jit(nopython=True)
def taur(V): #10**5  237            60    12    17             60    14           25
    return (10**5 * (237 * exp((V + 60) / 12) + 17 * exp(-(V + 60) / 14))**(-1) + 25)*1e-3

@jit(nopython=True)
def simulate(vlen, V0, w0, z0, r0, Gexc, Ginh, gLT, gh, VK, Vh, q10, dt,
             vi, vt, at, vr, glk, Vlk):

    # Time vector
    t = np.linspace(0, vlen, vlen)
    
    # Variables initialization
    V = np.zeros(vlen)
    w = np.zeros(vlen)
    z = np.zeros(vlen)
    r = np.zeros(vlen)
    
    iLT = np.zeros(vlen)
    ih = np.zeros(vlen)
    ilk = np.zeros(vlen)
    iexc = np.zeros(vlen)
    iinh = np.zeros(vlen)
    
    theta=np.zeros(vlen)
    theta1=np.zeros_like(theta)
    theta2=np.zeros_like(theta)
    aplist=np.zeros_like(theta)
    
    # Set initial conditions
    V[0] = V0
    w[0] = w0 # Low threshold K+ current
    z[0] = z0
    r[0] = r0 # Leak current
    theta1[0]=vt
    theta[0]=vt

    for i in range(1, vlen):
        # print(i/len(Vdata))

        # Get all the current and voltage values and update the voltage
        i_LT = gLT * w[i-1]**4 * z[i-1] * (V[i-1] - VK)
        i_h = gh * r[i-1] * (V[i-1] - Vh)  # something weird
        i_lk = glk * (V[i-1] - Vlk)

        # # Get all the current and voltage values and update the voltage
        # i_LT = gLT * w[i-1]*w[i-1]*w[i-1]*w[i-1]*z[i-1] * (V[i-1] - VK)
        # i_h = gh * r[i-1] * (V[i-1] - Vh)
        # i_lk = glk * (V[i-1] - Vlk)

        i_exc = Gexc[i-1]*V[i-1]
        i_inh = Ginh[i-1]*V[i-1]

        # dVdt = -(1 / C_m) * (i_LT + i_h + i_lk +i_exc-i_inh)
        dVdt = -(1 / C_m) * (i_LT + i_h +i_exc-i_inh)
        V[i] = V[i-1] + dVdt * dt

        # Add all the current values to a list for plotting
        iLT[i] = i_LT
        ih[i] = i_h
        iexc[i] = i_exc
        iinh[i] = i_inh
        ilk[i]=i_lk

        # Add the current value of each gating variable to a list containing
        # all the previous values, for plotting

        vprev = V[i-1] * 1e3

        w[i] = w[i-1] + ((winf(vprev) - w[i-1]) / tauw(vprev)) * dt * q10
        z[i] = z[i-1] + ((zinf(vprev) - z[i-1]) / tauz(vprev)) * dt * q10
        r[i] = r[i-1] + ((rinf(vprev) - r[i-1]) / taur(vprev)) * dt * q10
        
        dtheta1dt = 1/tautheta1*(-theta1[i-1] + thetainf(V[i-1], vi, vt, at))
        theta1[i] = theta1[i-1] + dtheta1dt*dt
        
        dtheta2dt=1/tautheta2*(-theta2[i-1])
        theta2[i]=theta2[i-1]+dtheta2dt*dt
        
        theta[i] = theta1[i]+theta2[i]
        

        if V[i]>theta[i]:
            theta2[i]+=alpha
            V[i]=vr
            aplist[i]=i*dt
        
        
    return V, t, w, z, r, iLT, ih, ilk, iexc, iinh, theta, aplist


def getstats(aplist):

    aps = [apind*delta_t for apind in aplist if apind!=0]
    
    tdiffs=np.diff(aps)
    
    tmean=np.mean(tdiffs)
    var=np.var(tdiffs)
    cv=var/tmean**2
    
    return tmean, var, cv

def getaps(aplist):
    return [apind*delta_t for apind in aplist if apind!=0]

@jit(nopython=True)
def thetainf(vm, vi, vt, at):
    if vm < vi:
        return vt
    else:
        return at*(vm-vi)+vt


# Main code -------------------------------------------------------------------

# Conductance generation
f=10 # exc
fi=10 # inh
y0e=0.8 # synthetic spiking variable amplitude
y0i=0.22
tauye=0.1 # decay rate of synthetic spiking variable
tauyi=0.1
tauie=0.01 # current decay rate
tauii=0.01
kie=0.000001 # convert trom y to I
kii=0.000001

# Threshold Lubejko parameters
tautheta1=37e-3
tautheta2=3.7e-3
vr=-62e-3
vi=-55e-3
vt=-31e-3
at=1
alpha=5e-3

# Conductance model parameters
gLT = 50e-9 # 50e-9 # X <---------------- #200e-9
gh = 100e-9  # 100e-9 # X <---------------- # 20e-9, 11e-9
glk = 2e-9  # Leakage conductance
VK = -0.08  # potassium reverse potential
Vh = -0.043  # hyperpolarizing reverse potential
Vlk = -0.065  # leakage reverse potential
V0 = -0.06  # initial membrane potential (mV)
w0 = 0.594  # Low-threshold K+ current
z0 = 0.608  # Low-threshold K+ current
r0 = 0.063  # Hyperpolarization current
C_m = 12e-12  # membrane capacitance (uF/cm^2)
q10=(3**((37-22)/10)) # heat parameter

# Simulation parameters
tmax=4
dt=1e-5
delta_t=0.001

tlisti, tliste, Ginh, Gexc, yi, ye = getcurrents(f, fi, y0e, y0i, tauye, tauyi, 
                                         tauie, tauii, kie, kii, tmax, 
                                         delta_t)
# Testing currents
Ginh=0*Ginh
Gexc=0*Gexc
se=500
ee=1200
Gexc[se:ee]=50e-9#*np.linspace(0,(end-st)*dt, end-st)
si=2000
ei=3000
Ginh[si:ei]=1e-9#*np.linspace(0,(end-st)*dt, end-st)

vlen=len(tliste)
V, t, w, z, r, iLT, ih, ilk, iexc, iinh, theta, aplist\
    =simulate(vlen, V0, w0, z0, r0, Gexc, Ginh, gLT, gh, 
              VK, Vh, q10, dt, vi, vt, at, vr, glk, Vlk)
aps=getaps(aplist)

fig, ax = plt.subplots(3, 1)
ax[0].plot(tliste, Gexc, label='Ge')
ax[0].plot(tliste, Ginh, label='Gi')
ax[0].set_ylabel('Gexc\n{} Hz'.format(f))
ax[0].set_xticks([])
ax[0].legend()
ax[1].plot(tlisti, iLT, label='iLT')
ax[1].plot(tlisti, ih, label='iH')
ax[1].plot(tlisti, ilk, label='iLK')
ax[1].set_ylabel('current')
ax[1].legend()
ax[2].plot(t * delta_t, V * 1000, label='V')
ax[2].plot(t * delta_t, vr * 1000 * np.ones(len(t)), 
           linestyle='-', color='gray', alpha=0.5, label='vr')
ax[2].plot(t * delta_t, vi * 1000 * np.ones(len(t)), 
           linestyle='--', color='gray', alpha=0.5, label='vi')
ax[2].plot(t * delta_t, theta * 1000 * np.ones(len(t)), 
           linestyle='-', color='k', alpha=1, label='vth')
ax[2].set_ylabel('Membrane\npotential\n(mV)')
ax[2].set_xlabel('Time (sec)')
ax[2].legend(loc='upper right')
plt.show()
