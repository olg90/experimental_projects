#%% Define the functions for fitting
import numpy as np
from matplotlib.pyplot import plot as pt
import matplotlib.pyplot as plt
from numpy.random import exponential, binomial, gamma
from numpy import exp
from numpy import sqrt as Sqrt
from numpy import log as Log
import pandas as pd
from numba import jit
import os
import re

def getiext(f, y0, tauy, taui, ki, tmax, dt):
    
        tlist=[]
        ylist=[]
        Iextlist=[]

        Iext=0
        y=0

        tcurr=0
        timer = dt
        e=1e-6
        while tcurr < tmax:
            t0=np.random.exponential(1/(f+e)) # action potential
            t1 = timer
            
            if t0 < t1:
                y += y0
                tmin=t0
                timer-=tmin
            else:
                Iextlist.append(Iext)
                ylist.append(y)
                tlist.append(tcurr)
                timer=dt
                tmin=timer
            tcurr += tmin

            # Update the continuous dynamics
            Iext += (-Iext/taui + ki*y)*tmin
            y += (-y/tauy)*tmin
            
        return np.array(tlist), np.array(ylist), np.array(Iextlist)

def getcurrents(f, fi, y0e, y0i, tauye, tauyi, tauie, tauii, kie, kii, tmax, dt):
    # Get the currents
    tlisti, yi, iext = getiext(fi, y0i, tauyi, tauii, kii, tmax, dt)
    tliste, ye, eext = getiext(f, y0e, tauye, tauie, kie, tmax, dt)
    # Make them the same size
    llist=[len(tlisti), len(tliste)]
    largmin=np.argmin(llist)
    if largmin==0:
        tliste = tliste[:llist[largmin]]
        eext = eext[:llist[largmin]]
    else:
        tlisti = tlisti[:llist[largmin]]
        iext = iext[:llist[largmin]]
    return tlisti, tliste, iext, eext, yi, ye

def getstats(aplist, ratio):

    aps = [apind*dt for apind in aplist if apind!=0]
    
    tdiffs=np.diff(aps)
    
    
    tmean=np.mean(tdiffs)
    var=np.var(tdiffs)
    cv=var/tmean**2
    
    return tmean, var, cv

def getaps(aplist, dt):
    return np.where(aplist!=0)[0]*dt

@jit(nopython=True)
def thetainf(vm, vi, vt, at):
    if vm < vi:
        return vt
    else:
        return at*(vm-vi)+vt
    
def gspikes(Gexc, Ginh, args):
    for x in args:
        if x[3]==1:
            Gexc[x[0]:x[0]+x[1]]=x[2]
        if x[3]==-1:
            Ginh[x[0]:x[0]+x[1]]=x[2]
    return Gexc, Ginh

@jit(nopython=True)
def rinf(V):
    # value = 76 # original
    value = 76 # slightly better subthreshold fit
    return (1 + exp((V + value) / 7))**(-1)
# KLVT - low threshold potassium current - K+ ions flow out of neuron 
# (positive current) 
# low threshold potassium current, hyperpolarize when subthreshold polarized 
@jit(nopython=True) 
def winf(V):#1            48    6 ------------------------------------------------------------------- (CHANGED HERE)
    return (1 + exp(-(V + 48) / 6))**(-1 / 4)
@jit(nopython=True) # low threshold potassium current KLT
def zinf(V):
    zeta = 0.5 #0.5                           71    10 ------------------------------------------------------------------- (CHANGED HERE)
    return (1 - zeta)*(1 + exp((V + 100) / 10))**(-1) + zeta

@jit(nopython=True)
#            v - better at 1000                                                                    shift hmp lft
def tauw(V): #100  6          60      6    16*0.2            60    45           1.5
    return (100 * (6 * exp((V+ 60) / 6) + 16*0.2 * exp(-(V + 60) / 45))**(-1) + 1.5)*1e-3
@jit(nopython=True)
def tauz(V):# 1000          60    20    0.2           60    8           50
    return (1000 * (exp((V + 60) / 20) + 0.2*exp(-(V + 60) / 8))**(-1) + 50)*1e-3
# END CHANGE ---------------------------------------------------------------------------------------- End change

@jit(nopython=True)
def taur(V): #10**5  237            60    12    17             60    14           25
    return (10**5 * (237 * exp((V + 60) / 12) + 17 * exp(-(V + 60) / 14))**(-1) + 25)*1e-3

@jit(nopython=True)
def simulate(vlen, V0, w0, z0, r0, Gexc, Ginh, gLT, gh, VK, Vh, q10, dt,
             vi, vt, at, vr, glk, Vlk, rf, alpha, tautheta1, tautheta2):

    # Time vector
    t = np.linspace(0, vlen, vlen)
    
    # Variables initialization
    V = np.zeros(vlen)
    w = np.zeros(vlen)
    z = np.zeros(vlen)
    r = np.zeros(vlen)
    
    iLT = np.zeros(vlen)
    ih = np.zeros(vlen)
    ilk = np.zeros(vlen)
    iexc = np.zeros(vlen)
    iinh = np.zeros(vlen)
    
    theta=np.zeros(vlen)
    theta1=np.zeros_like(theta)
    theta2=np.zeros_like(theta)
    aplist=np.zeros_like(theta)
    
    # Set initial conditions
    V[0] = V0
    w[0] = w0 # Low threshold K+ current
    z[0] = z0
    r[0] = r0 # Leak current
    theta1[0]=vt
    theta[0]=vt
    
    rfon=False
    rftimer = np.inf
    
    for i in range(1, vlen):
        # Get all the current and voltage values and update the voltage
        i_LT = gLT * w[i-1]**4 * z[i-1] * (V[i-1] - VK)
        i_h = gh * r[i-1] * (V[i-1] - Vh)
        i_lk = glk * (V[i-1] - Vlk)
        
        Vexc=0
        Vinh=-0.085 # should be -85 mV
        i_exc = Gexc[i-1]*(V[i-1]-Vexc) # Conductance based model current is 
        i_inh = Ginh[i-1]*(V[i-1]-Vinh) # calculated from the 
        
        # iext = ic + iion
        # ic = iext - iion
        # C * dvdt = iext - iion
        # dvdt = (1/C) * (iext - iion)
        # dvdt = (1/C) * (gE(V-VE)+gI(V-Vi)-I=iion)
        
        i_ext = i_exc-i_inh
        i_ion = i_LT+i_h
        
        # dVdt = -(1 / C_m) * (i_LT + i_h + i_lk +i_exc-i_inh)
        dVdt = (1 / C_m) * (-i_ext-i_ion)
        V[i] = V[i-1] + dVdt * dt*(1-rfon)
        
        # Add all the current values to a list for plotting
        iLT[i] = i_LT
        ih[i] = i_h
        iexc[i] = i_exc
        iinh[i] = i_inh
        ilk[i]=i_lk

        # Add the current value of each gating variable to a list containing
        # all the previous values, for plotting
        vprev = V[i-1] * 1e3
        w[i] = w[i-1] + ((winf(vprev) - w[i-1]) / tauw(vprev)) * dt * q10
        z[i] = z[i-1] + ((zinf(vprev) - z[i-1]) / tauz(vprev)) * dt * q10
        r[i] = r[i-1] + ((rinf(vprev) - r[i-1]) / taur(vprev)) * dt * q10
        
        # Thresholds
        dtheta1dt = 1/tautheta1*(-theta1[i-1] + thetainf(V[i-1], vi, vt, at))
        theta1[i] = theta1[i-1] + dtheta1dt*dt
        dtheta2dt=1/tautheta2*(-theta2[i-1])
        theta2[i]=theta2[i-1]+dtheta2dt*dt
        theta[i] = theta1[i]+theta2[i]
        
        if rftimer!=np.inf:
            rftimer-=dt
            
        if rftimer<=0:
            rftimer=np.inf
            rfon=False
        
        if V[i]>theta[i]:
            theta2[i]+=alpha
            V[i]=vr
            aplist[i]=i*dt
            rfon=True
            rftimer=rf
            
    return V, t, w, z, r, iLT, ih, ilk, iexc, iinh, theta, aplist

# Main code -------------------------------------------------------------------

# Conductance generation
f=25 # exc
fi=25 # inh
y0e=1 # synthetic spiking variable amplitude
y0i=1
tauye=0.1 # decay rate of synthetic spiking variable
tauyi=0.1
tauie=0.001 # current decay rate
tauii=0.001
kie=35e-6 # convert trom y to I
kii=5e-6

# Threshold Lubejko parameters
tautheta1=3e-3
tautheta2=25e-3
vr=-62e-3
vi=-45e-3
vt=-31e-3
at=0.8
alpha=100e-3
rf=1e-3 # 1e-3

# Conductance model parameters
gLT = 50e-9 # 50e-9 # X <---------------- #200e-9
gh = 100e-9  # 100e-9 # X <---------------- # 20e-9, 11e-9
glk = 5e-9  # Leakage conductance
VK = -80e-3  # potassium reverse potential
Vh = -43e-3  # hyperpolarizing reverse potential
Vlk = -65e-3  # leakage reverse potential
V0 = -60e-3  # initial membrane potential (mV)
w0 = 0.594  # Low-threshold K+ current
z0 = 0.608  # Low-threshold K+ current
r0 = 0.063  # Hyperpolarization current
C_m = 12e-12  # membrane capacitance (uF/cm^2)
q10=(3**((37-22)/10)) # heat parameter

# Simulation parameters
tmax=6
dt=1e-5

tlisti, tliste, Ginh, Gexc, yi, ye = getcurrents(f, fi, y0e, y0i, tauye, tauyi, 
                                         tauie, tauii, kie, kii, tmax, 
                                         dt)


# =============================================================================
# # Testing currents
# Ginh=0*Ginh
# Gexc=0*Gexc
# # Gexc[500:1200]=30e-9#*np.linspace(0,(end-st)*dt, end-st)
# Gexc, Ginh =gspikes(Gexc, Ginh, [
#                          [500,700,30e-9,1], 
#                          [1500,500,10e-9,-1],
#                          [2500,500,30e-9,1],
#                          [2500,500,30e-9,1],
#                          [3500,500,10e-9,-1],
#                          [4050,500,30e-9,1]])
# =============================================================================

# =============================================================================
# # Testing conductances
# Ginh=Ginh*0
# Gexc=Gexc*0
# Gexc[100000:120000]=1e-6
# 
# =============================================================================
vlen=len(tliste)
V, t, w, z, r, iLT, ih, ilk, iexc, iinh, theta, aplist\
    =simulate(vlen, V0, w0, z0, r0, Gexc, Ginh, gLT, gh, 
              VK, Vh, q10, dt, vi, vt, at, vr, glk, Vlk, rf, alpha,
              tautheta1, tautheta2)
aps=getaps(aplist, dt)

fs = 15
plt.subplot(3, 1, 1)
plt.plot(tliste, Gexc, label='Ge {} Hz'.format(f))
plt.plot(tliste, Ginh, label='Gi {} Hz'.format(fi))
plt.ylabel('Conductance', fontsize=fs)
plt.xticks([], fontsize=fs)
plt.yticks(fontsize=fs)
plt.legend(loc='upper right', fontsize=fs)

plt.subplot(3, 1, 2)
plt.plot(tlisti, iLT, label='iLT')
plt.plot(tlisti, ih, label='iH')
# plt.plot(tlisti, ilk, label='iLK')
plt.ylabel('Current', fontsize=fs)
plt.xticks([], fontsize=fs)
plt.yticks(fontsize=fs)
plt.legend(loc='upper right', fontsize=fs)

plt.subplot(3, 1, 3)
plt.plot(t * dt, V * 1000, label='V')
plt.plot(t * dt, vr * 1000 * np.ones(len(t)), linestyle='-', color='gray', alpha=0.5, label='vr')
plt.plot(t * dt, vi * 1000 * np.ones(len(t)), linestyle='--', color='gray', alpha=0.5, label='vi')
plt.plot(t * dt, theta * 1000 * np.ones(len(t)), linestyle='-', color='k', alpha=1, label='vth')
plt.ylabel('Membrane\npotential (mV)', fontsize=fs)
plt.xlabel('Time (sec)', fontsize=fs)
plt.yticks(fontsize=fs)
plt.xticks(fontsize=fs)
plt.legend(loc='upper right', fontsize=fs)
for x in aps:
    plt.axvline(x, color='r', alpha=0.6)
plt.show()


#%% Real data
def filter_by_sequence(strings, x1, x2, x3):
    """
    Given a list of strings, return those that contain
    the sequence _x1_, _x2_, _x3_ in order.
    """
    pattern = fr"_{x1}_.+?_{x2}_.+?_{x3}_"
    result = [s for s in strings if re.search(pattern, s)]
    return result

def getrates(se, si, dsus):
    if se==1:
        excnum=2
    elif se==4:
        excnum=1
    elif se==10:
        excnum=0
        
    if si==2:
        inhnum=2
    elif si==4:
        inhnum=1
    elif si==8:
        inhnum=0
    return dsus[7*excnum:7*(excnum+1), inhnum] # Mean sustained rate

def getcondsdata(df, se, si, fi, st=5000, en=25000):
    titles = df.keys()
    # Find matching columns for this specific combination
    matches = filter_by_sequence(titles, se, si, fi)
    
    if len(matches) == 0:
        raise ValueError(f"No columns match the sequence _{se}_ _{si}_ _{fi}_")
    
    # Take the first match (assumes first column is excitatory, second inhibitory)
    data = np.array(df[matches])
    return data

# Main code -------------------------------------------------------------------

directory=r'C:\Users\ogamb\OneDrive\Desktop\German group current data\Conductance Stimuli'
os.chdir(directory)
# files=[x for x in os.listdir() if x[-1]=='x']
files=['Rep1.xlsx','Rep10.xlsx','Rep2.xlsx','Rep3.xlsx','Rep4.xlsx',
 'Rep5.xlsx','Rep6.xlsx','Rep7.xlsx','Rep8.xlsx','Rep9.xlsx']
# dfs=[pd.read_excel(x) for x in files]
# df=pd.read_excel(files[0]) # <------- Uncomment this when first running

# Load the entire Excel file
file_path = r"C:\Users\ogamb\OneDrive\Desktop\Research\current_project\postinhibitory_facilitation\allcellscopy.xlsx"  # Change this to your actual path
# Read all data into a dictionary
datainh = pd.read_excel(file_path, sheet_name=None, header=None)
names = ['Summary', '240425_E4', '240425_E5', '240425_E6', 
         '240426_E2', '240426_E3', '240426_E5', '240515_E2', 
         '240516_E2', '240516_E7']
d=datainh[names[0]]
dsus=np.array(d.iloc[1:, -3:]) # all the sustained rate data  

# Threshold Lubejko parameters
tautheta1=1e-3
tautheta2=20e-3
vr=-70e-3
vi=-55e-3
vt=-50e-3 # threshold base
at=0.8
alpha=40e-3
rf=1e-3 # 1e-3

# Conductance model parameters - fixed
gLT = 50e-9 # 50e-9 # X <---------------- #200e-9
gh = 100e-9  # 100e-9 # X <---------------- # 20e-9, 11e-9
glk = 5e-9  # Leakage conductance
VK = -80e-3  # potassium reverse potential
Vh = -43e-3  # hyperpolarizing reverse potential
Vlk = -65e-3  # leakage reverse potential
V0 = -60e-3  # initial membrane potential (mV)
w0 = 0.594  # Low-threshold K+ current
z0 = 0.608  # Low-threshold K+ current
r0 = 0.063  # Hyperpolarization current
C_m = 12e-12  # membrane capacitance (uF/cm^2)
q10=(3**((37-22)/10)) # heat parameter

# Simulation parameters
dt=1e-4

se=1 # 1,4,8
si=2 # 2,4,8
fi=300 # 0,50,100,150,200,250,300

def getfout(se, si, fi, df, dsus):
    titles = df.keys()
    matches = filter_by_sequence(titles, se, si, fi) # get the dataset
    cdata = np.array(df[matches]) # conductance data
    # Want the steady state current # 5000 start of current injection
    st=5000 # start plot, 5000 for start of conductance injection
    en=25000 # end plot
    Gexc = np.abs(cdata[st:en, 0])
    Ginh = np.abs(cdata[st:en, 1])
    Gexc=Gexc*1e-8
    Ginh=Ginh*1e-8
    msusrate=getrates(se,si,dsus) # mean sustained rate
    vlen=len(Gexc)
    V, t, w, z, r, iLT, ih, ilk, iexc, iinh, theta, aplist\
        =simulate(vlen, V0, w0, z0, r0, Gexc, Ginh, gLT, gh, 
                  VK, Vh, q10, dt, vi, vt, at, vr, glk, Vlk, rf, alpha,
                  tautheta1, tautheta2)
    aps=getaps(aplist, dt)
    sustime=int(0.18*len(Gexc))*dt
    aps=[ap for ap in aps if ap>sustime]
    fout=1/(np.mean(np.diff(aps)))
    return t, Gexc, Ginh, iLT, ih, V, theta, msusrate, aps, sustime, fout

# =============================================================================
# t, Gexc, Ginh, iLT, ih, V, theta, msusrate, aps, sustime, fout\
#     = getfout(se, si, fi, df, dsus)
# fs = 15
# plt.subplot(3, 1, 1)
# plt.plot(t*dt, Gexc, label='Ge {} Hz'.format(300))
# plt.plot(t*dt, Ginh, label='Gi {} Hz'.format(fi))
# plt.ylabel('Conductance', fontsize=fs)
# plt.xticks([], fontsize=fs)
# plt.yticks(fontsize=fs)
# plt.legend(loc='upper right', fontsize=fs)
# 
# plt.subplot(3, 1, 2)
# plt.plot(t*dt, iLT, label='iLT')
# plt.plot(t*dt, ih, label='iH')
# # plt.plot(tlisti, ilk, label='iLK')
# plt.ylabel('Current', fontsize=fs)
# plt.xticks([], fontsize=fs)
# plt.yticks(fontsize=fs)
# plt.legend(loc='upper right', fontsize=fs)
# 
# plt.subplot(3, 1, 3)
# plt.plot(t*dt , V * 1000, label='V')
# plt.plot(t*dt , vr * 1000 * np.ones(len(t)), linestyle='-', 
#          color='gray', alpha=0.5, label='vr')
# plt.plot(t*dt, vi * 1000 * np.ones(len(t)), linestyle='--', 
#          color='gray', alpha=0.5, label='vi')
# plt.plot(t*dt, theta * 1000 * np.ones(len(t)), linestyle='-', 
#          color='k', alpha=1, label='vth')
# plt.ylabel('Membrane\npotential (mV)', fontsize=fs)
# plt.xlabel('Time (sec)', fontsize=fs)
# plt.yticks(fontsize=fs)
# plt.xticks(fontsize=fs)
# plt.legend(loc='upper right', fontsize=fs)
# for x in aps:
#     plt.axvline(x, color='r', alpha=0.6)
# plt.title('Fout={}, se={}, si={}, fi={}'.format(np.around(fout,3), 
#           se, si, fi))
# plt.axvline(sustime, color='blue')
# plt.show()
# =============================================================================

# main plot

    
fs=15
filist=[0,50,100,150,200,250,300]
foutlist=[]
for i, fi in enumerate(filist):
    print(i, len(filist))
    t, Gexc, Ginh, iLT, ih, V, theta, msusrate, aps, sustime, fout\
        = getfout(se, si, fi, df, dsus)
    foutlist.append(fout)
plt.plot(filist, msusrate, marker='o', label='exc={}, inh={}'.format(se, si))
plt.plot(filist, foutlist, marker='o', label='Simulation')
plt.ylabel('Steady state mean firing rate', fontsize=fs)
plt.xlabel('Inhibitory neuron frequency', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)
plt.legend(fontsize=fs-3)
plt.show()
